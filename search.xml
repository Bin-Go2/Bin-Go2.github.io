<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-剑指Offer篇</title>
    <url>/2020/09/05/Algorithm-jianzhioffer/</url>
    <content><![CDATA[<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span>(<span class="params">s,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>

<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    n &gt; <span class="number">1</span> <span class="keyword">and</span> sumNums(n<span class="number">-1</span>) <span class="comment"># n=1 终止递归的需求，可通过短路效应实现</span></span><br><span class="line">    res += n </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">  <span class="comment"># 1.数学 (sum(set(nums))*3-sum(nums))//2  2.字典思路 3. 位运算</span></span><br><span class="line">  <span class="comment"># a^a = 0  a^0 = a 位运算</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>): <span class="comment"># 1 &lt;= nums[i] &lt; 2^31限制</span></span><br><span class="line">        idx = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 0001   0010   0010</span></span><br><span class="line">        count = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; idx !=<span class="number">0</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count%<span class="number">3</span> ==<span class="number">1</span>: <span class="comment"># 表明唯一的那个数在这一位上为1</span></span><br><span class="line">            res = res|idx</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br><span class="line"><span class="comment"># 非递归方法： BFS 获得层数即二叉树的深度</span></span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 遍历统计链表长度，倒是第k个节点便是顺数n-k个节点</span></span><br><span class="line">    <span class="comment"># 快慢指针思路</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># 快指针先走k步</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 递归出口</span></span><br><span class="line">    root.left, root.right = self.mirrorTree(root.right),self.mirrorTree(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 非递归方法： BFS 对每一层进行迭代 </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 对每一层的每一个节点进行遍历</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        tmp_left, tmp_right =node.left, node.right</span><br><span class="line">        <span class="keyword">if</span> tmp_left:</span><br><span class="line">            queue.append(tmp_left)</span><br><span class="line">            node.right = tmp_left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> tmp_right:</span><br><span class="line">            queue.append(tmp_right)</span><br><span class="line">            node.left = tmp_right  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.left = <span class="literal">None</span>              </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n) ]</span><br></pre></td></tr></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">head</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        res.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]    </span><br><span class="line"><span class="comment"># 递归解法 return reversePrint(head.next) + [head.val] if head else []</span></span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    cur,pre = head,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp </span><br><span class="line">    <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">root, k</span>):</span></span><br><span class="line">    <span class="comment"># 中序遍历 获得有序数组后返回第k个大的数字。 中序遍历： 左子树 + root + 右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            res+=(traverse(root.left)) <span class="comment"># 注意不能使用append  否则会形成一个嵌套列表 </span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            res+=(traverse(root.right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表####"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a>####</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1,l2</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 新建一个链表，依次插入合适的节点</span></span><br><span class="line">    cur = dummy = ListNode(<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.next, l1 = l1, l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.next, l2 = l2, l2.next</span><br><span class="line">        cur = cur.next</span><br><span class="line">    cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 使用递归进行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 位运算 n&amp;(n−1)  二进制数字n最右边的 1 变成 0 ，其余不变。</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        n &amp;= n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># n&amp;1 =1 =&gt; n 二进制 最右一位 为 1 ；n&amp;1 = 0 =&gt; n 二进制 最右一位 为 0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n&amp;<span class="number">1</span></span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.A,self.B = [],[]</span><br><span class="line">       <span class="comment"># A 负责入队  B负责出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Commands Often Used</title>
    <url>/2020/09/05/Commands%20often%20used/</url>
    <content><![CDATA[<h2 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1. hexo"></a>1. hexo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&#x27;post&#x27;</span> <span class="comment"># Create a new post</span></span><br><span class="line">$ hexo g  <span class="comment"># Generate static files  </span></span><br><span class="line">$ hexo s  <span class="comment"># Run server</span></span><br><span class="line">$ hexo d  <span class="comment"># Deploy to remote sites</span></span><br><span class="line">$ hexo clean <span class="comment"># Remove cache file (db.json) and static files (public)</span></span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Commands</tag>
      </tags>
  </entry>
</search>
