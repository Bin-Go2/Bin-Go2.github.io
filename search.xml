<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-剑指Offer</title>
    <url>/2020/09/05/Algorithm-jianzhioffer/</url>
    <content><![CDATA[<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span>(<span class="params">s,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>

<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    n &gt; <span class="number">1</span> <span class="keyword">and</span> sumNums(n<span class="number">-1</span>) <span class="comment"># n=1 终止递归的需求，可通过短路效应实现</span></span><br><span class="line">    res += n </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">    fre_dict=&#123;&#125; <span class="comment"># 使用字典</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        fre_dict[i] = fre_dict.get(i,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> fre_dict[i]&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 另一种思路 ，排序 找nums[i] == nums[i-1]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span>(<span class="params">nums</span>):</span> </span><br><span class="line">    tmp_res = <span class="number">0</span>     </span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_res = tmp_res ^ i  <span class="comment"># 假设需要的结果为为a和b 那么tmp_res = a^b  note: a^a = 0 </span></span><br><span class="line">    <span class="comment"># 将数组分成两部分 一部分只包含a  另一部分只包含b</span></span><br><span class="line">    pivot = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> tmp_res&amp;pivot ==<span class="number">0</span>:</span><br><span class="line">        pivot = pivot&lt;&lt;<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i &amp;pivot:</span><br><span class="line">            a = a^i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b^i</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">  <span class="comment"># 1.数学 (sum(set(nums))*3-sum(nums))//2  2.字典思路 3. 位运算</span></span><br><span class="line">  <span class="comment"># a^a = 0  a^0 = a 位运算</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>): <span class="comment"># 1 &lt;= nums[i] &lt; 2^31限制</span></span><br><span class="line">        idx = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 0001   0010   0010</span></span><br><span class="line">        count = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; idx !=<span class="number">0</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count%<span class="number">3</span> ==<span class="number">1</span>: <span class="comment"># 表明唯一的那个数在这一位上为1</span></span><br><span class="line">            res = res|idx</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br><span class="line"><span class="comment"># 非递归方法： BFS 获得层数即二叉树的深度</span></span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 遍历统计链表长度，倒是第k个节点便是顺数n-k个节点</span></span><br><span class="line">    <span class="comment"># 快慢指针思路</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># 快指针先走k步</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 递归出口</span></span><br><span class="line">    root.left, root.right = self.mirrorTree(root.right),self.mirrorTree(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 非递归方法： BFS 对每一层进行迭代 </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 对每一层的每一个节点进行遍历</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        tmp_left, tmp_right =node.left, node.right</span><br><span class="line">        <span class="keyword">if</span> tmp_left:</span><br><span class="line">            queue.append(tmp_left)</span><br><span class="line">            node.right = tmp_left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> tmp_right:</span><br><span class="line">            queue.append(tmp_right)</span><br><span class="line">            node.left = tmp_right  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.left = <span class="literal">None</span>              </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n) ]</span><br></pre></td></tr></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">head</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        res.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]    </span><br><span class="line"><span class="comment"># 递归解法 return reversePrint(head.next) + [head.val] if head else []</span></span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    cur,pre = head,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp </span><br><span class="line">    <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">root, k</span>):</span></span><br><span class="line">    <span class="comment"># 中序遍历 获得有序数组后返回第k个大的数字。 中序遍历： 左子树 + root + 右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            res+=(traverse(root.left)) <span class="comment"># 注意不能使用append  否则会形成一个嵌套列表 </span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            res+=(traverse(root.right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表####"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a>####</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1,l2</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 新建一个链表，依次插入合适的节点</span></span><br><span class="line">    cur = dummy = ListNode(<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.next, l1 = l1, l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.next, l2 = l2, l2.next</span><br><span class="line">        cur = cur.next</span><br><span class="line">    cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 使用递归进行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 位运算 n&amp;(n−1)  二进制数字n最右边的 1 变成 0 ，其余不变。</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        n &amp;= n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># n&amp;1 =1 =&gt; n 二进制 最右一位 为 1 ；n&amp;1 = 0 =&gt; n 二进制 最右一位 为 0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n&amp;<span class="number">1</span></span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.A,self.B = [],[]</span><br><span class="line">       <span class="comment"># A 负责入队  B负责出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

<h4 id="复杂链表的复制-待定"><a href="#复杂链表的复制-待定" class="headerlink" title="复杂链表的复制 ##待定"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a> ##待定</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">head</span>):</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先-待定"><a href="#二叉树的最近公共祖先-待定" class="headerlink" title="二叉树的最近公共祖先##待定"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a>##待定</h4><h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="comment"># 滑动窗口解决</span></span><br><span class="line">    nums = list(range(<span class="number">1</span>,(target//<span class="number">2</span>+<span class="number">2</span>))) <span class="comment"># 候选的最大值不会超高target/2 +1</span></span><br><span class="line">    res = []</span><br><span class="line">    start_window,total = <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> end_window <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        total += nums[end_window]</span><br><span class="line">        <span class="keyword">while</span> total&gt;=target:</span><br><span class="line">            <span class="keyword">if</span> total == target:  <span class="comment"># 窗口和 = target =&gt;当前窗口加入结果 窗口起点右移</span></span><br><span class="line">                res.append(nums[start_window:end_window+<span class="number">1</span>])</span><br><span class="line">            total -= nums[start_window]</span><br><span class="line">            start_window+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    root = preorder[<span class="number">0</span>]</span><br><span class="line">    pos = inorder.index(root)</span><br><span class="line"></span><br><span class="line">    binary_tree = TreeNode(root)</span><br><span class="line">    binary_tree.left = self.buildTree(preorder[<span class="number">1</span>:pos+<span class="number">1</span>],inorder[:pos])</span><br><span class="line">    binary_tree.right = self.buildTree(preorder[pos+<span class="number">1</span>:],inorder[pos+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> binary_tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从上到下打印二叉树-I"><a href="#从上到下打印二叉树-I" class="headerlink" title="从上到下打印二叉树 I"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 I</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>


<h4 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># BFS 层序遍历 使用队列实现</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        cur_level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            cur_level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(cur_level)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>

<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxValue</span>(<span class="params">grid</span>):</span> </span><br><span class="line">    <span class="comment"># 二维dp  grid[i][j] = max(grid[i][j - 1], grid[i - 1][j]) +  grid[i][j]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>: grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">    <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]  <span class="comment">#  排序后取中间的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Boyer-Moore 投票法 O(n)</span></span><br><span class="line">    res = nums[<span class="number">0</span>]</span><br><span class="line">    cal = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> cal ==<span class="number">0</span>: </span><br><span class="line">            res = i</span><br><span class="line">        <span class="keyword">if</span> i == res:</span><br><span class="line">            cal+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cal-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums,target</span>):</span>  </span><br><span class="line">    left, right = <span class="number">0</span>,len(nums)<span class="number">-1</span> <span class="comment"># 使用双指针 空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">        sums = nums[left]+nums[right]</span><br><span class="line">        <span class="keyword">if</span> sums&lt;target:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sums&gt;target:</span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums[left],nums[right]]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 带条件的动态规划</span></span><br><span class="line">    dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        n2, n3, n5 = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">        dp[i] = min(n2, n3, n5)</span><br><span class="line">        <span class="keyword">if</span> dp[i] == n2: a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n3: b += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n5: c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">    left,right = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">    <span class="comment"># 保证nums[left]奇数,nums[right]为偶数</span></span><br><span class="line">        <span class="keyword">if</span> nums[left]%<span class="number">2</span>==<span class="number">1</span>:  </span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[right]%<span class="number">2</span> ==<span class="number">1</span>:</span><br><span class="line">                nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">prices</span>):</span></span><br><span class="line">    <span class="comment"># opt[i] = max(opt[i-1],prices[i]-min(prices[:i])) 动态规划转移方程</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    min_price = prices[<span class="number">0</span>] <span class="comment"># 存储当天前最低的股票</span></span><br><span class="line">    opt = [<span class="number">0</span>]*len(prices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i]&lt;min_price:</span><br><span class="line">            min_price = prices[i]</span><br><span class="line">        opt[i] = max(opt[i<span class="number">-1</span>],prices[i]-min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> opt[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strToInt</span>(<span class="params">self, str: str</span>) -&gt; int:</span></span><br><span class="line">    sign,res = <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    str = str.strip()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 情况1: 字符串只有空格</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="comment"># 首先判断第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> : sign = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>: sign = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span>&lt;=str[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>:res = res*<span class="number">10</span> + int(str[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span>&lt;=i&lt;=<span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            res = res*<span class="number">10</span> + ord(i) - ord(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sign&gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res*sign <span class="keyword">if</span> res*sign &gt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">else</span>  <span class="number">-2</span>**<span class="number">31</span></span><br></pre></td></tr></table></figure>

<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: float, n: int</span>) -&gt; float:</span></span><br><span class="line">    <span class="comment">### 分治思想</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># base </span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span> : x,n = <span class="number">1</span>/x,-n  </span><br><span class="line">    <span class="keyword">if</span> n %<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x,n//<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x * self.myPow(x,n//<span class="number">2</span>)**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">数字序列中某一位的数字</a></h4><h4 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> len(nums) <span class="comment"># 类似 [0]这样的情况，缺失的为1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 排序数组中的搜索问题，首先想到&quot;二分&quot;解决。</span></span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Commands Often Used</title>
    <url>/2020/09/05/Commands%20Often%20Used/</url>
    <content><![CDATA[<h2 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1. hexo"></a>1. hexo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&#x27;post&#x27;</span> <span class="comment"># Create a new post</span></span><br><span class="line">$ hexo g  <span class="comment"># Generate static files  </span></span><br><span class="line">$ hexo s  <span class="comment"># Run server</span></span><br><span class="line">$ hexo d  <span class="comment"># Deploy to remote sites</span></span><br><span class="line">$ hexo clean <span class="comment"># Remove cache file (db.json) and static files (public)</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Efficiency</category>
      </categories>
      <tags>
        <tag>Commands</tag>
      </tags>
  </entry>
  <entry>
    <title>DSCI551 outline</title>
    <url>/2020/09/06/DSCI551-outline/</url>
    <content><![CDATA[<h2 id="DSCI551-Foundations-of-Data-Management"><a href="#DSCI551-Foundations-of-Data-Management" class="headerlink" title="DSCI551 - Foundations of Data Management"></a>DSCI551 - Foundations of Data Management</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/09/06/Firebase-rest-web-api/" title="Firebase rest &amp; web api">Firebase rest &amp; web api</a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2020/09/08/Storage-systems/" title="Storage systems">Storage systems</a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="/2020/09/10/File-Systems/" title="File systems">File systems</a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="/2020/09/11/NFS/" title="Network File System">Network File System</a></h3>]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase rest &amp; web api</title>
    <url>/2020/09/06/Firebase-rest-web-api/</url>
    <content><![CDATA[<h2 id="Firebase-概述（BaaS）"><a href="#Firebase-概述（BaaS）" class="headerlink" title="Firebase 概述（BaaS）"></a>Firebase 概述（BaaS）</h2><p>Firebase谷歌的一款应用后台服务。借助Firebase，应用开发者们可以快速搭建应用后台。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ol>
<li>Firebase (realtime) database: Manage <strong>JSON</strong> documents + Real-time <strong>syncing</strong> data between users and devices</li>
<li>Firebase (cloud) storage: Store images, photos, videos</li>
<li>Firebase (user) authentication: Support sign in using Google, Facebook</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>Create a Firebase account: first use Google account,then go to Firebase console: <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a></li>
<li>Click on “Add project”  to create a Firebase project</li>
<li>Add Firebase to your web app</li>
<li>any other interesting operation …</li>
</ol>
<h3 id="关于-Realtime-database"><a href="#关于-Realtime-database" class="headerlink" title="关于 Realtime database"></a>关于 Realtime database</h3><ul>
<li>Data in JSON(Javascript Object Notation) format  <a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a> </li>
<li>When creating a real-time database, we should open up the access to allow us to read and write the data.</li>
<li>There are some difference between storing style from JSON file and Firebase real-time database<ol>
<li>JSON文件中的array元素在Realtime database下以object的形式存在，object对应的key为数组元素的索引</li>
<li>JSON文件可以保存value为null的键值对，Realtime database则会忽略这一对键值对<br><img src="/image/firebase1.png"></li>
</ol>
</li>
</ul>
<h2 id="Firebase-REST-API"><a href="#Firebase-REST-API" class="headerlink" title="Firebase REST API"></a>Firebase REST API</h2><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p> REST：Representation State Transfer，表现层状态转移<br> 一句话解释的话就是:通过URL定位资源，用HTTP动词（GET, POST, PUT, DELETE)描述操作从而用来实现前后端数据传输的协议。</p>
<h3 id="命令行进行http数据传输：curl"><a href="#命令行进行http数据传输：curl" class="headerlink" title="命令行进行http数据传输：curl"></a>命令行进行http数据传输：curl</h3><p>  For command operation, it’s convenient to use <strong>curl</strong> (Command line tool for data transfer)<br>  curl详细使用：<a href="https://itbilu.com/linux/man/4yZ9qH_7X.html">https://itbilu.com/linux/man/4yZ9qH_7X.html</a><br>  注意，curl大小写敏感，请求的命令参数均为大写字符</p>
<h3 id="curl例子-CRUD"><a href="#curl例子-CRUD" class="headerlink" title="curl例子 - CRUD"></a>curl例子 - CRUD</h3><p>  PUT &amp; POST (C), GET (R), PATCH (U) ,DELETE (D)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JSON tree:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;isMarried&quot;</span>: false,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="string">&quot;height_cm&quot;</span>: <span class="number">167.6</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;streetAddress&quot;</span>: <span class="string">&quot;22nd Street&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;NY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postalCode&quot;</span>: <span class="string">&quot;10021-3100&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;phoneNumbers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;212 555-1234&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;office&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;646 555-4567&quot;</span>,</span><br><span class="line">      <span class="string">&quot;xyz&quot;</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;spouse&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;scores&quot;</span>: [<span class="number">8.5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GET-get-the-specific-resource"><a href="#GET-get-the-specific-resource" class="headerlink" title="GET: get the specific resource"></a>GET: get the specific resource</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;address&#x2F;city.json&#39;   return: &quot;New York&quot;%  </span><br><span class="line">-X   可以省略 直接 curl GET url; GET  可以省略 直接 curl url</span><br><span class="line"></span><br><span class="line">$ curl &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;phoneNumbers&#x2F;0.json&#39; #refer to arr element by index</span><br><span class="line">return:&#123;&quot;number&quot;:&quot;212 555-1234&quot;,&quot;type&quot;:&quot;home&quot;&#125;%  </span><br></pre></td></tr></table></figure>

<h4 id="PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”"><a href="#PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”" class="headerlink" title="PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)"></a>PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add if node not exists (could add embedded nodes) - 添加数据</span><br><span class="line">Overwrite if node already has value               - 重写数据</span><br><span class="line"></span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Mary&quot;&#39;  # 注意引号</span><br><span class="line"></span><br><span class="line">#This will add a new node &quot;country&quot; (assuming it does not exist yet) </span><br><span class="line">#and a child of this node with key &quot;province&quot; and content: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;</span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country&#x2F;province.json&#39; -d &#39;&#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#39; </span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="POST-add-new-value-to-a-given-node"><a href="#POST-add-new-value-to-a-given-node" class="headerlink" title="POST: add new value to a given node"></a>POST: add new value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Automatically generates a new key &amp; then stores the value for the new key</span><br><span class="line">由于对于添加的数据，其自动生成一个key，所以保证不会重写数据(In contrast, PUT will simply overwrite the key)</span><br><span class="line"> </span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d  &#39;&quot;Anhui&quot;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="PATCH-upsert-a-value-to-a-given-node"><a href="#PATCH-upsert-a-value-to-a-given-node" class="headerlink" title="PATCH:  upsert a value to a given node"></a>PATCH:  upsert a value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Performs the update if value already exists  -更新节点</span><br><span class="line">Otherwise, it inserts the new value          -插入新节点</span><br><span class="line">PATCH本质上是一个深度搜索符合节点的条件进行更新或者添加)</span><br><span class="line"></span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Hubei&quot;&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处:相比于PUT（对于已经存在的节点进行全局的修改），本质上来说PATCH实现的是对该节点的局部更新</span><br><span class="line">注意:当需要更新的节点没有子节点（仅仅是一个key-value格式），无法使用PATCH，因为 -d 参数后需要传入键值对的格式</span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # fail</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &quot;Invalid data; couldn&#39;t parse JSON object. Are you sending a JSON object with valid key names?&quot;</span><br><span class="line">&#125;</span><br><span class="line">curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # success</span><br></pre></td></tr></table></figure>
<h4 id="DELETE-delete-a-node"><a href="#DELETE-delete-a-node" class="headerlink" title="DELETE:  delete a node"></a>DELETE:  delete a node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X DELETE &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39;</span><br></pre></td></tr></table></figure>

<h4 id="从数据增加、减少上对PUT、PATCH和POST进行比较"><a href="#从数据增加、减少上对PUT、PATCH和POST进行比较" class="headerlink" title="从数据增加、减少上对PUT、PATCH和POST进行比较"></a>从数据增加、减少上对PUT、PATCH和POST进行比较</h4><p>PUT可能造成数据的增加（添加新节点下的value）和减少（overwrite整个节点导致其内嵌的节点被删除）；<br>PATCH可能造成数据的增加（添加新节点下的value)和减少（update节点的用更少的数据去取代原先的数据）<br>POST一定会造成数据的增加（因为会自动加上key）；</p>
<h4 id="data-querying-by-RESful-API"><a href="#data-querying-by-RESful-API" class="headerlink" title="data querying by RESful API"></a>data querying by RESful API</h4><ul>
<li>orderBy=”$key”  </li>
<li>orderBy=”<path-to-child-key>“</li>
<li>orderBy=”$value”  需要在Realtime database的Rules先声明</li>
<li>startAt/endAt</li>
<li>equalTo</li>
<li>limitToFirst/limitToLast </li>
</ul>
<p>Specified in database rules:<br><a href="https://firebase.google.com/docs/database/security/indexing-data">https://firebase.google.com/docs/database/security/indexing-data</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;equalTo&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;startAt&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$value&quot;&#39;</span><br><span class="line"></span><br><span class="line">Orders ascendingly:</span><br><span class="line">null -&gt; false -&gt;true -&gt; number -&gt; string -&gt; object</span><br></pre></td></tr></table></figure>


<h2 id="REST-API-in-Python"><a href="#REST-API-in-Python" class="headerlink" title="REST API in Python"></a>REST API in Python</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;xxxx&#39;</span><br><span class="line">data &#x3D; &#39;xxx&#39;</span><br><span class="line"></span><br><span class="line">requests.get(url) </span><br><span class="line">requests.put(url, data)</span><br><span class="line">requests.patch(url, data)</span><br><span class="line">requests.delete(url)</span><br><span class="line">requests.post(url, data)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Commands</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON-review</title>
    <url>/2020/09/07/JSON-review/</url>
    <content><![CDATA[<h2 id="JSON概述"><a href="#JSON概述" class="headerlink" title="JSON概述"></a>JSON概述</h2><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation)，由道格拉斯·克罗克福特构想和设计、轻量级的数据交换语言,该语言以易于让人阅读的文字为基础，用来<strong>传输由属性值或者序列性的值组成的数据对象</strong>。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式。</p>
<ul>
<li>Light-weight data exchange format<br>Much simpler than XML; Language-independent; Inspired by the syntax of JavaScript object literals</li>
<li>Some differences from JavaScript objects<br><strong>String in JSON must be double-quoted</strong>; Okay to single-quote in JavaScript (&amp; Python)</li>
<li>JSON is case-sensitive</li>
</ul>
<p>一句话表达就是，JSON是一种格式，基于文本，优于轻量，用于交换数据，由于其用文本格式的保存方式，所以一般也叫JSON字符串。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>value = string | number | object | array | true | false | null</li>
<li>object = {} | { members }<ul>
<li>members = pair | pair, members </li>
<li>pair = string : value</li>
</ul>
</li>
<li>array = [] | [ elements ]<ul>
<li>elements = value | value, elements</li>
</ul>
</li>
</ul>
<p>一般情况下，JSON大多为一个array，array里的每一个元素为一个object，object可以理解为字典<br>JSON 在线检查器:   <a href="https://www.json.cn/">https://www.json.cn/</a></p>
<h2 id="Python中使用JSON"><a href="#Python中使用JSON" class="headerlink" title="Python中使用JSON"></a>Python中使用JSON</h2><h3 id="encode-decode"><a href="#encode-decode" class="headerlink" title="encode/decode"></a>encode/decode</h3><p>JSON操作主要分为两个：</p>
<ol>
<li>encode，将Python对象转化为JSON文本，主要函数 dump( ) dumps( )</li>
<li>decode，将JSON文本转化为Python对象，主要函数 load( ) loads( )</li>
</ol>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><table>
<thead>
<tr>
<th align="center">Python</th>
<th align="center">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="center">list/tuple</td>
<td align="center">array</td>
</tr>
<tr>
<td align="center">dict</td>
<td align="center">object</td>
</tr>
<tr>
<td align="center">None</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">True</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">‘abc’</td>
<td align="center">“abc”</td>
</tr>
</tbody></table>
<p>关于Python字典转JSON文本的说明：</p>
<ul>
<li>Keys in Python can be number, string, or tuple. </li>
<li>Number is also converted to string.</li>
<li>But tuple (with two or more components) is not acceptable by dumps()/dump()</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="comment"># json库为Python自带的标准库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON encoder Python object =&gt; JSON document   </span></span><br><span class="line">json.dumps([<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="literal">True</span>, <span class="literal">None</span>])  <span class="comment"># &#x27;[3, &quot;abc&quot;, true, null]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python object =&gt; JSON file</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_file:</span><br><span class="line">    json.dump(data,out_file)</span><br><span class="line"></span><br><span class="line"><span class="comment">## JSON decoder </span></span><br><span class="line">json.loads(<span class="string">&#x27;[&quot;foo&quot;, &#123;&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]&#125;]&#x27;</span>) <span class="comment"># [&#x27;foo&#x27;, &#123;&#x27;bar&#x27;: [&#x27;baz&#x27;, None, 1.0, 2]&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON file =&gt; Python object</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">    data = json.load(in_file)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>File Format</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage systems</title>
    <url>/2020/09/08/Storage-systems/</url>
    <content><![CDATA[<h2 id="Storage-Device"><a href="#Storage-Device" class="headerlink" title="Storage Device"></a>Storage Device</h2><h3 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h3><p><img src="/image/storage_hierarchy.png"></p>
<h3 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h3><ul>
<li>Capacity(bytes) - How much data it can hold</li>
<li>Cost($) -  Price per byte of storage</li>
<li>Bandwidth(bytes/sec) - Number of bytes that can be transferred per second;  read and write bandwidth may be different</li>
<li>Latency(sec) - Time elapsed, waiting for response/delivery of data</li>
</ul>
<h3 id="Basic-Function-CRUD"><a href="#Basic-Function-CRUD" class="headerlink" title="Basic Function : CRUD"></a>Basic Function : CRUD</h3><ul>
<li>C(reate)/write</li>
<li>R(ead)</li>
<li>U(pdate)/overwrite</li>
<li>D(elete)</li>
</ul>
<h3 id="Some-terms"><a href="#Some-terms" class="headerlink" title="Some terms"></a>Some terms</h3><ul>
<li>Access times: Time taken before drive is ready to transfer data 一般来说，物理设备（硬盘，内存..）在进行数据的转换前需要索引到目标位置， 内存-纳秒 SSD-微秒 HDD-毫秒</li>
<li>Access pattern: how storage read/write data <ul>
<li>Sequential: Data to be accessed are located next to each other or sequentially on the device</li>
<li>Random: Access data located randomly on storage device</li>
</ul>
</li>
<li>Completion Time：Time to complete an read/write operation <ul>
<li><strong>CompletionTime = Latency + Size/Bandwidth</strong></li>
<li>Depends on lots of factors(device, operation type, access pattern…)</li>
</ul>
</li>
</ul>
<p>Note: 这里主要讨论HDD和SSD</p>
<h2 id="Hard-Disk-Drive"><a href="#Hard-Disk-Drive" class="headerlink" title="Hard Disk Drive"></a>Hard Disk Drive</h2><h3 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/hdd.png"></p>
<ul>
<li>One or more spinning magnetic platters, typically two surface per platter</li>
<li>Data stored in tracks</li>
<li>Disk arm positions over the radial positon - swings across tracks but don’t extend</li>
<li>Data is read/written by disk head as platter spins</li>
</ul>
<p>Hard disk head movement while copying files between two folders：<br><a href="https://www.youtube.com/watch?v=BlB49F6ExkQ">https://www.youtube.com/watch?v=BlB49F6ExkQ</a></p>
<h3 id="Physical-characteristics"><a href="#Physical-characteristics" class="headerlink" title="Physical characteristics"></a>Physical characteristics</h3><ul>
<li>3.5” (diameter, common in desktops), 2.5” (common in laptops)</li>
<li>Rotational Speed: 4800/5400/7200/10000 RPM (rotations per minute)</li>
<li>Between 5-7 platters</li>
<li>Current capacity up to 10TB</li>
</ul>
<h3 id="Data-Storage"><a href="#Data-Storage" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>1 platter  is divided into a number of tracks</li>
<li>1 tracker is divided into N fixed size sectors<ul>
<li>sector size: 4KB</li>
<li>Entire sector is written “atomically” -&gt; sector为最小的操作单元，所以不论读写都首先进行sector的寻址</li>
</ul>
</li>
</ul>
<h3 id="Address-Method-CHS-cylinder-head-sector"><a href="#Address-Method-CHS-cylinder-head-sector" class="headerlink" title="Address Method - CHS(cylinder-head-sector)"></a>Address Method - CHS(cylinder-head-sector)</h3><h4 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h4><p>CHS is an early way to address a sector. (LBA(Logical Block Addressing) is  more common now.) </p>
<p><img src="/image/CHS.png"></p>
<p>举个例子：<br>#cylinders: 256<br>#heads: 16 (i.e., 8 platters, 2 heads/platter)<br>#sectors/track: 64<br>sector size = 4KB<br>=&gt; capacity of the drive:  2^8 * 2^6 * 2^2* 2^10 * 2^4 = 2^30 = 1GB</p>
<h4 id="address-step"><a href="#address-step" class="headerlink" title="address step"></a>address step</h4><p><strong>According to CHS, data can be located before transferring, then data can be transferred</strong></p>
<ol>
<li>Wait for the disk haed on right track    - seek time <ol>
<li>On average seek time is about  1⁄3  max seek time</li>
<li><img src="/image/seek-time.png"></li>
</ol>
</li>
<li>wait for the right sector to rotate under the head. - rotational latency <ol>
<li>On average: about 1⁄2 of time of a full rotation</li>
<li>example:  Assume 10,000 RPM (rotations per minute) 60000 ms/ 10000 rotations  = 6ms / rotation</li>
</ol>
</li>
</ol>
<h3 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h3><blockquote>
<p>T = T_seek + T_rotation + T_transfer<br>T_seek : Time to get the disk head on right track<br>T_rotation :Time to wait for the right sector to rotate under the head<br>T_transfer: Time to actually transfer data</p>
</blockquote>
<h4 id="T-transfer"><a href="#T-transfer" class="headerlink" title="T_transfer"></a>T_transfer</h4><p>Assume that data will be transferred:  512KB, 128 MB/sec transmission bandwidth<br>Transfer time:  512KB/128MB * 1000ms = 4ms</p>
<h4 id="Actual-Bandwidth"><a href="#Actual-Bandwidth" class="headerlink" title="Actual Bandwidth"></a>Actual Bandwidth</h4><p>Actual Bandwidth = data / actual time ，所以一般情况下实际带宽会小</p>
<h4 id="数据传输中的block和sector区分"><a href="#数据传输中的block和sector区分" class="headerlink" title="数据传输中的block和sector区分"></a>数据传输中的block和sector区分</h4><ul>
<li>Sector is the  basic unit of hard disk dirve</li>
<li>Block is the basic unit of file system</li>
<li>Block has 1 or more sectors  （in this course, assuming one block = one sector）</li>
</ul>
<p>硬盘本身没有block的概念，block概念存在于文件系统的概念中，文件系统是一个块一个块的读取数据，如果是按照一个sector一个sector的来读数据，太慢了，所以才有了block这样一个逻辑块的概念。</p>
<h4 id="不同access-pattern对读写的影响"><a href="#不同access-pattern对读写的影响" class="headerlink" title="不同access pattern对读写的影响"></a>不同access pattern对读写的影响</h4><ul>
<li>Sequential operation:<ul>
<li>May assume all sectors involved are on the same track<br>– need to seek to the right track or rotate to the first sector （一次seektime）<br>– But no rotation/seeking needed afterwardSSD</li>
</ul>
</li>
<li>Random operation:  <ul>
<li>May assume all sectors are on different tracks and sectors （多次seektime）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example: 7ms avg seek,  10,000 RPM  50 MB/sec transfer rate 4KB/block</span><br><span class="line">Sequential access of 10 MB:</span><br><span class="line">– Completion time = 7ms + 60*1000/10000/2 ms + 10/50 *1000 ms = 210ms</span><br><span class="line">– Actual bandwidth = 10MB/210ms = 47.62 MB/s</span><br><span class="line"></span><br><span class="line">Random access of 10 MB </span><br><span class="line">– block numbers: 10*1000/4 = 2500  (assume 1 block = 1 sector)</span><br><span class="line">– Completion time = 2500 * (7 + 3 + 4/50) = 25.2s</span><br><span class="line">– Actual bandwidth = 10MB / 25.2s = 0.397 MB/s</span><br></pre></td></tr></table></figure>

<h2 id="Soild-State-Drive"><a href="#Soild-State-Drive" class="headerlink" title="Soild State Drive"></a>Soild State Drive</h2><h3 id="Organization-1"><a href="#Organization-1" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/ssd.png"></p>
<p>SSD contains a number of flash memory chips</p>
<p><img src="/image/chip.png"></p>
<p>chip -&gt; dies -&gt; planes -&gt; blocks -&gt; pages (rows) -&gt; cells</p>
<h3 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h3><ul>
<li>All electronic, made from flash memory</li>
<li>Limited lifetime, can only write a limited number of times.</li>
<li>More expensive, less capacity  - 3 times or more expensive</li>
<li>Significantly better latency: no seek or rotational delay</li>
<li>Much better performance on random (however, write has much higher latency than read )</li>
</ul>
<h3 id="Data-Storage-1"><a href="#Data-Storage-1" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>Cells are made of floating-gate transistors : By applying high positive/negative voltage to control gate, electrons can be attracted to or repelled from floating gate<ul>
<li>State = 1, if no electrons in the floating gate</li>
<li>State = 0, if there are electrons (negative charges)<br>– Electrons stuck there even when power is off<br>– So state is retained</li>
</ul>
</li>
<li>Data in SSD are represented by the ‘01010…’ formats, that is the state of the electrons</li>
</ul>
<p><img src="/image/floating-gate.png"></p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul>
<li>Electrons on the floating gate affect the threshold voltage for the floating gate transistor to conduct</li>
<li>Higher voltage needed when gate has electrons</li>
</ul>
<p><img src="/image/ssd_read.png"></p>
<p>Steps: </p>
<ol>
<li>Apply Vint (intermediate voltage) </li>
<li>If the current is detected, gate has no electrons=&gt; bit = 1</li>
<li>If no current, gate must have electrons =&gt; bit = 0</li>
</ol>
<p><u><strong>Page is the smallest unit that can be read</strong></u></p>
<h4 id="Write-and-Erase"><a href="#Write-and-Erase" class="headerlink" title="Write and Erase"></a>Write and Erase</h4><h4 id="Write-and-erase"><a href="#Write-and-erase" class="headerlink" title="Write and erase"></a>Write and erase</h4><ul>
<li>Write: 1 =&gt; 0 (get electron)<ul>
<li>Apply high positive voltage (&gt;&gt; voltage for read) to the control gate</li>
<li>Attract electrons from channel to floating gate (through quantum tunneling)</li>
<li>Page is the smallest unit for write</li>
</ul>
</li>
<li>Erase: 0 =&gt; 1 (make electrons empty)<ul>
<li>Need to apply much higher negative voltage to the control gate</li>
<li>Get rid of electrons from floating gate</li>
<li>May stress surrounding cells(dangerous to do on individual pages)</li>
<li>Block is the smallest unit for erase</li>
</ul>
</li>
</ul>
<h3 id="P-E-cycle"><a href="#P-E-cycle" class="headerlink" title="P/E cycle"></a>P/E cycle</h3><blockquote>
<p>P/E cycle: Data is written to cells (P) and then erased (E)<br>Every write &amp; erase damages oxide layer surrounding the floating-gate to some extent</p>
</blockquote>
<ul>
<li>Page is the smallest unit for read and write (write is also called program, 1-&gt;0)</li>
<li>Block is the smallest unit for erase (0-&gt;1) – i.e., make cells “empty” (i.e., no electrons)  (关于为什么使用block作为最小擦除单元：SSD的物理结构导致，擦除过程会作用到整个block施加高电压，将电子吸引出来)</li>
</ul>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>CSCI570-outline</title>
    <url>/2020/09/08/CSCI570-outline/</url>
    <content><![CDATA[<p>hello world!</p>
]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-滑动窗口</title>
    <url>/2020/09/09/Algorithm-sliding-window/</url>
    <content><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><u>连续</u>子数组</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据要求，找到第一个满足条件的窗口</li>
<li>调整窗口(右移/左移)使其继续满足要求，并进行重复</li>
<li>得到最合适的窗口即为答案</li>
</ul>
<h3 id="Leetcode例题"><a href="#Leetcode例题" class="headerlink" title="Leetcode例题"></a>Leetcode例题</h3><h5 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_start,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        char = s[window_end]</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> dic <span class="keyword">and</span> dic[char]&gt;=window_start: <span class="comment"># 注意这里的第二个条件dic[char]&gt;=window_start！！ 起到一个覆盖的作用</span></span><br><span class="line">            window_start = dic[char] +<span class="number">1</span></span><br><span class="line">        dic[char] = window_end</span><br><span class="line">        width = window_end-window_start+<span class="number">1</span></span><br><span class="line">        res = max(width,res)</span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h5 id="大小为-K-且平均值大于等于阈值的子数组数目"><a href="#大小为-K-且平均值大于等于阈值的子数组数目" class="headerlink" title="大小为 K 且平均值大于等于阈值的子数组数目"></a><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">大小为 K 且平均值大于等于阈值的子数组数目</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numOfSubarrays</span>(<span class="params">arr,k,threshold</span>):</span></span><br><span class="line">    <span class="keyword">if</span> arr == [] <span class="keyword">or</span> len(arr)&lt;k:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_sum,window_start,res = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    temp = threshold*k</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        window_sum+=arr[window_end]</span><br><span class="line">        <span class="keyword">if</span> window_end&gt;=k<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> window_sum &gt;=temp:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            window_sum-=arr[window_start]</span><br><span class="line">            window_start+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h5><h5 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></h5><h5 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h5>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Network File System</title>
    <url>/2020/09/11/NFS/</url>
    <content><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p>The Network File System (NFS) is a client/server application that lets a computer user view and optionally store and update files on a remote computer as though they were on the user’s own computer. NFS is a distributed file system(DFS).</p>
<h4 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client/server architecture"></a>Client/server architecture</h4><p><img src="/image/C-S.png"></p>
<p>Advantage</p>
<ul>
<li>Easy sharing of data across clients</li>
<li>Centralized administration</li>
<li>Security</li>
</ul>
<p>Disadvantage:</p>
<ul>
<li>Network overhead</li>
<li>More components to fail</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p><img src="/image/DFS.png"></p>
<h4 id="Stateless-无状态协议"><a href="#Stateless-无状态协议" class="headerlink" title="Stateless  - 无状态协议"></a>Stateless  - 无状态协议</h4><ul>
<li>Server does not keep track of states of clients<ul>
<li>Which files are currently open at which clients</li>
<li>Current position/offset of file</li>
<li>Which clients have read/cached which blocks</li>
</ul>
</li>
<li>Requests from clients must make sure:<ul>
<li>the server can deliver all the information needed to complete the requests</li>
<li>do not rely on previous requests</li>
</ul>
</li>
</ul>
<h4 id="file-handle"><a href="#file-handle" class="headerlink" title="file handle"></a>file handle</h4><ul>
<li>Volume (file system) identifier<ul>
<li>Which volume? (e.g. partition C or D if NTFS)</li>
</ul>
</li>
<li>Inode number<ul>
<li>Which file in the volume?</li>
</ul>
</li>
<li>Generation number<ul>
<li>Needed since inode number may be reused at the server (e.g., after file has been deleted by other clients)</li>
</ul>
</li>
</ul>
<p><strong>Client uses file handle to communication with server</strong><br><img src="/image/file-handle.png"></p>
<h4 id="RPC-Remote-procedure-call"><a href="#RPC-Remote-procedure-call" class="headerlink" title="RPC - Remote procedure call"></a>RPC - Remote procedure call</h4><ul>
<li>Remote server publishes a set of procedures, for example f(args)<ul>
<li>example: NFSPROC_LOOKUP for lookup file handle ,read, write, create, remove, etc.</li>
</ul>
</li>
<li>In making RPC calls,(客户端调用)<ul>
<li>Client notifies remote server of executing f &amp; sends over arguments args for f</li>
<li>Server executes f(args) =&gt; results </li>
<li>Server sends back results</li>
</ul>
</li>
</ul>
<h3 id="Operations-on-remote-file"><a href="#Operations-on-remote-file" class="headerlink" title="Operations on remote file"></a>Operations on remote file</h3><p>All CRUD operations use <u>file handle</u></p>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p><u>First obtain file handle via lookup</u></p>
<ul>
<li>File handle for the root directory may be obtained via the mount protocol</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Look up &quot;&#x2F;foo&#x2F;more&#x2F;bar.txt&quot;</span><br><span class="line">– First, use &#x2F; file handle to obtain foo&#39;s handle  </span><br><span class="line">	File handle for the root directory may be obtained via the mount protocol</span><br><span class="line">– Next, use foo&#39;s handle to obtain more&#39;s handle</span><br><span class="line">– Finally, use more&#39;s handle to obtain bar.txt handle</span><br></pre></td></tr></table></figure>

<p><u>Then use file handle to read data</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_READ(file handle, offset, count)</span><br><span class="line">- offset here is explicit</span><br><span class="line">– Return: data + file attributes</span><br><span class="line">– File attributes include modification time, useful for client-size cache validation</span><br><span class="line"></span><br><span class="line">Compared to local file system</span><br><span class="line">- n &#x3D; read(fd, buffer, size)</span><br><span class="line">– n is the number of bytes actually read</span><br></pre></td></tr></table></figure>


<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><p><u>First obtain file handle via lookup</u></p>
<p><u>Then use file handle to write data</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_WRITE(file handle, offset, count, data)</span><br><span class="line">– Return: file attributes</span><br><span class="line">– Note again explicit offset is specified in the call</span><br><span class="line"></span><br><span class="line">Compared to local file system</span><br><span class="line">– n &#x3D; write(fd, buffer, size)</span><br><span class="line">– Offset is again implicit (current position)</span><br></pre></td></tr></table></figure>

<h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_CREATE(directory file handle, name of file in the directory, attributes)</span><br><span class="line">– Return: file handle</span><br></pre></td></tr></table></figure>

<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_REMOVE(directory file handle, name of file to be removed)</span><br><span class="line">– Return: Nothing</span><br></pre></td></tr></table></figure>

<h3 id="Failures"><a href="#Failures" class="headerlink" title="Failures"></a>Failures</h3><h4 id="Cases"><a href="#Cases" class="headerlink" title="Cases"></a>Cases</h4><p>Case1: request lost<br>Case2: Server down<br>Case3: Reply lost on way back from Sever</p>
<h3 id="More-details"><a href="#More-details" class="headerlink" title="More details"></a>More details</h3><p>学习资源: <a href="https://tools.ietf.org/html/rfc1094">https://tools.ietf.org/html/rfc1094</a></p>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>File systems</title>
    <url>/2020/09/10/File-Systems/</url>
    <content><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><blockquote>
<p>A filesystem is the methods and data structures that an operating system uses to keep track of files on a disk or partition; that is, the way the files are organized on the disk.</p>
</blockquote>
<ul>
<li>File content stored in blocks on storage device</li>
<li>Files are organized into directories (folders)<br><img src="/image/file-system.png"></li>
</ul>
<h3 id="Detail-about-file"><a href="#Detail-about-file" class="headerlink" title="Detail about file"></a>Detail about file</h3><h4 id="File-descriptor"><a href="#File-descriptor" class="headerlink" title="File descriptor"></a>File descriptor</h4><p>A file descriptor is a number that uniquely identifies an open file in a computer’s operating system. It describes a data resource, and how that resource may be accessed.<br>简单的说，根据Linux一切皆文件的概念来看，当进程打开或者创建文件的时候，内核会向进程返回一个数字，这个数字就是文件描述符，所有执行I/O操作的系统调用都通过文件描述符来进行。</p>
<h4 id="Hard-link-and-symbolic-link-soft-link"><a href="#Hard-link-and-symbolic-link-soft-link" class="headerlink" title="Hard link and symbolic link/soft link"></a>Hard link and symbolic link/soft link</h4><p>A hard link is essentially a synced carbon copy of a file that refers directly to the inode of a file. Symbolic links on the other hand refer directly to the file which refers to the inode, a shortcut.</p>
<p><img src="/image/hard-soft-link.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ln a.txt b.txt    <span class="comment"># 创建硬链接 - 副本</span></span><br><span class="line">$ ln -s a.txt c.txt <span class="comment"># 创建软链接 - 替身（快捷方式）</span></span><br><span class="line">$ unlink c.txt      <span class="comment"># 取消链接</span></span><br></pre></td></tr></table></figure>

<h4 id="File-permission-mode"><a href="#File-permission-mode" class="headerlink" title="File permission mode"></a>File permission mode</h4><p>3种模式  r:read w:write x:execute<br>3种身份: user group others<br>3*3 = 27 种访问权限<br>rw-r–r– =&gt; 110 (owner permission) 100 (group) 100 (others)<br>可以使用<code>chomod</code> 来进行权限的修改</p>
<h4 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h4><p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. <a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">更多inode细节</a> </p>
<ul>
<li>Stores metadata/attributes about the file ( use <code>stat file</code> to check the metadata )</li>
<li>Also stores locations of blocks holding the content of the file</li>
</ul>
<h5 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">More details about the file metadata</span><br><span class="line"></span><br><span class="line">struct stat &#123;</span><br><span class="line">dev_t st_dev; &#x2F;* ID of device containing file *&#x2F;</span><br><span class="line">ino_t st_ino; &#x2F;* inode number *&#x2F;</span><br><span class="line">mode_t st_mode; &#x2F;* protection *&#x2F;</span><br><span class="line">nlink_t st_nlink; &#x2F;* number of (hard) links *&#x2F;</span><br><span class="line">uid_t st_uid; &#x2F;* user ID of owner *&#x2F;</span><br><span class="line">gid_t st_gid; &#x2F;* group ID of owner *&#x2F;</span><br><span class="line">dev_t st_rdev; &#x2F;* device ID (if special device file, e.g., &#x2F;etc&#x2F;tty) *&#x2F; </span><br><span class="line">off_t st_size; &#x2F;* total size, in bytes *&#x2F;</span><br><span class="line">blksize_t st_blksize; &#x2F;* blocksize for filesystem I&#x2F;O *&#x2F;</span><br><span class="line">blkcnt_t st_blocks; &#x2F;* number of blocks allocated *&#x2F;</span><br><span class="line">time_t st_atime; &#x2F;* last time file content was accessed *&#x2F;</span><br><span class="line">time_t st_mtime; &#x2F;* last time file content was modified *&#x2F; </span><br><span class="line">time_t st_ctime; &#x2F;* last time inode was changed *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">time_t st_atime; &#x2F;* last time file content was accessed *&#x2F; 关于这一项的思考：</span><br><span class="line">这一项表明了不论对文件是什么操作，都会进行inode的修改，有的时候为了提升I&#x2F;O性能，会在挂载文件系统的时候指定“noatime,nodiratime”参数，意味着当访问一个文件和目录的时候，access time都不会更新</span><br><span class="line">可以通过 cat &#x2F;etc&#x2F;fstab 查看具体信息</span><br></pre></td></tr></table></figure>
<p><img src="/image/inode.png"></p>
<h5 id="locations-of-data"><a href="#locations-of-data" class="headerlink" title="locations of data"></a>locations of data</h5><p>An inode has:</p>
<ul>
<li>A number of direct pointers,each points to a data block<br>example: a inode has 8 pointers, each pointer points to a 4K block, then this inode is enogh for 8*4K = 32KB size of file</li>
<li>Also has a slot for indirect pointer : a pointer points to a data block storing direct pointers<br>example: 1 block’s size: 4KB, pointer size: 4 bytes, then a block can hold 1024 pointers =&gt; Now file can have (8 + 1024) blocks , enough for 4MB size of file</li>
</ul>
<p>How to store larger files? - Multi-level index</p>
<ul>
<li>Pointers may be organized into multiple levels (double,triple,…n times) </li>
</ul>
<p><img src="/image/double-indirect-pointers.png"><br>1 direct pointer =&gt; 1 block (4KB)<br>1 indirect pointer =&gt; 2^10 direct pointer  =  2^10*4KB  = 4MB<br>1 double indirect pointer =&gt; 2^10 indirect pointers =&gt; 2^20 direct pointers  =&gt; 2^20*4KB = 4GB</p>
<h4 id="Organization-of-blocks"><a href="#Organization-of-blocks" class="headerlink" title="Organization of blocks"></a>Organization of blocks</h4><p>Assumption:(便于理解，做些假设)</p>
<ol>
<li>Disk consists of a list of blocks and they are array-based.(other forms:Tree-based, e.g., SGI XFS -Blocks are organized into variable-length extents)</li>
<li>a disk with 64 blocks<ul>
<li>4KB/block   =&gt;文件系统的最小单元</li>
<li>512B/sector =&gt;存储系统的最小单元 </li>
<li>so there are 2^12/2^9 = 2^3 = 8 sectors/block and capacity of disk = 64 * 4KB = 256KB</li>
</ul>
</li>
</ol>
<p>Structure about these blocks: </p>
<ol>
<li>Data region (56 blocks (#8-63))</li>
<li>Inode table (5 blocks #3 – #7) 元数据+文件内容地址<ul>
<li>assume 256 bytes/inode 5 blocks, 4KB/block</li>
<li>=&gt; 80 inodes total  (4KB/256B * 5)</li>
<li>=&gt; File system can store at most 80 files</li>
</ul>
</li>
<li>Bitmaps (#1, #2)  a vector of bits, 0 for free (inode/block), 1 for in-use<ul>
<li>Inode bitmap (imap):keep track of which inodes in the inode table are available  (这里4KB一个block 1byte=8bit，所以一个block的话最多以存储80K个inode的状态)</li>
<li>Data bitmap (dmap):keep track of which blocks in data region are available</li>
</ul>
</li>
<li>Superblock(#0): Track where i/d blocks and inode table are; Indicate type of FS &amp; inumber of its root dir; Will be read first when file system is mounted</li>
</ol>
<p><img src="/image/block_info_fs.png"></p>
<h4 id="Inumber"><a href="#Inumber" class="headerlink" title="Inumber"></a>Inumber</h4><p>Each inode is identified by a number: Low-level number of file name<br>Can figure out location of inode from inumber 通过inumber可以寻址到其代表的inode所在的sector<br>Location:  ⌊(inodeStartAddress + inumber ∗ inode size)/sector size⌋</p>
<p>example: inumber = 32<br>Address:12K+32*256=20K<br>Sector #: 20K/512 = 40<br><img src="/image/inumber.png"></p>
<p>总结inumber,inode,data一句话来说就是inumber =&gt; inode =&gt; data</p>
<h3 id="Detail-about-directory"><a href="#Detail-about-directory" class="headerlink" title="Detail about directory"></a>Detail about directory</h3><h4 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h4><ul>
<li>Directory itself stored as a file</li>
<li>For each file in the directory, it stores:<ul>
<li>name, inumber, record length, string length</li>
</ul>
</li>
<li>If file is deleted (using rm command) or a name is unlinked (using unlink command),then inumber in its directory entry set to 0 (reserved for empty entry)<ul>
<li>File is finally deleted when its last (hard) link is removed<br><img src="/image/directory.png"></li>
</ul>
</li>
</ul>
<h4 id="Storing-a-directory"><a href="#Storing-a-directory" class="headerlink" title="Storing a directory"></a>Storing a directory</h4><ul>
<li>Also as a file with its own inode + data block</li>
<li>inode:<ul>
<li>file type: directory (instead of regular file)</li>
<li>pointer to block(s) in data region storing directory entries</li>
</ul>
</li>
</ul>
<h3 id="Operations-on-file"><a href="#Operations-on-file" class="headerlink" title="Operations on file"></a>Operations on file</h3><ul>
<li>Create: open(), write()</li>
<li>Read:  open(),read(), lseek()</li>
<li>Update: write(), lseek()</li>
<li>Delete: unlink()</li>
</ul>
<p>Note: 这些函数都是操作系统自带提供的系统调用函数</p>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul>
<li>User interface via GUI or touch command in Linux</li>
<li>Implementation, e.g., via a C program with a system call: open()</li>
<li>open() returns a file descriptor. Reserved fds: stdin 0, stdout, 1, stderr 2</li>
<li>After getting the file descriptor of file, start read() <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd &#x3D; open(&quot;&#x2F;foo&#x2F;bar&quot;, O_RDONLY)</span><br><span class="line">- Need to locate inode of the file &quot;&#x2F;foo&#x2F;bar&quot;</span><br><span class="line">- Assume inumber of root, say 2, is known (e.g., when the file system is mounted)</span><br><span class="line"></span><br><span class="line">step1: read inode and content of &#x2F;  (2 reads)</span><br><span class="line">- Look for &quot;foo&quot; in &#x2F; -&gt; foo&#39;s inumber</span><br><span class="line"></span><br><span class="line">step2: read inode and content of &#x2F;foo (2 reads)</span><br><span class="line">- Look for &quot;bar&quot; in &#x2F;foo -&gt; bar&#39;s inumber</span><br><span class="line"></span><br><span class="line">step3: read inode of &#x2F;foo&#x2F;bar (1 read)</span><br><span class="line">– Permission check + allocate file descriptor</span><br><span class="line"></span><br><span class="line">open-file table per process(维护这些进程，系统有一个 open-file table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(fd, buffer, size)</span><br><span class="line">– Note fd is maintained in per-process open-file table</span><br><span class="line">– Table translates fd -&gt; inumber of file</span><br><span class="line"></span><br><span class="line">step1: consult bar&#39;s inode to locate a block</span><br><span class="line">step2: read the block</span><br><span class="line">step3: update inode with newest file access time</span><br><span class="line">step4: update open-file table with new offset</span><br><span class="line">step5: repeat above steps until done(with reading data of given size)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/image/read.png"></li>
</ul>
<p>I/O cost for open(): 5 reads<br>I/O cost for reading a block: 2 reads + 1 write</p>
<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;foo&#x2F;bar&quot;, O_WRONLY)</span><br><span class="line">– Or int fd &#x3D; create((&quot;&#x2F;foo&#x2F;bar&quot;)</span><br><span class="line">– Assume bar is a new file under foo</span><br><span class="line"></span><br><span class="line">step1: read&#39;&#x2F;&#39;inode &amp; content -&gt; obtain foo&#39;s inumber</span><br><span class="line">step2: read&#39;&#x2F;foo&#39;inode &amp; content -&gt; check if bar exists</span><br><span class="line">step3: read imap,to find a free inode for bar</span><br><span class="line">step4: update imap,setting 1 for allocated inode</span><br><span class="line">step5: write bar&#39;s inode</span><br><span class="line">step6: update foo&#39;s content block  - adding an entry for bar</span><br><span class="line">step7: update foo&#39;s inode  -update its modification time</span><br><span class="line"></span><br><span class="line">write(fd, buffer, size)</span><br><span class="line">step1: read inode of bar(by looking up its inumber in the open-file table)</span><br><span class="line">step2: allocate new data block – read and write bmap</span><br><span class="line">step3: write to data block of bar</span><br><span class="line">step4: update bar node - new modification time, add pointer to block</span><br></pre></td></tr></table></figure>
<p><img src="/image/write.png"></p>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>spaCy学习</title>
    <url>/2020/09/10/spacy-learning/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>spaCy (/speɪˈsiː/) is an open-source software library for advanced natural language processing written in the programming languages Python and Cython.</p>
</blockquote>
<p>学习资源: <a href="https://spacy.io/">https://spacy.io/</a>  <a href="https://course.spacy.io/en">https://course.spacy.io/en</a></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>nlp   : contains the processing pipeline; includes language-specific rules for tokenization etc.</li>
<li>doc   : access information about the text in a structured way, and no information is lost.</li>
<li>token : tokens in a document – for example, a word or a punctuation character.</li>
<li>span  : a slice of the document consisting of one or more tokens</li>
<li>lexical attributes : <code>token.i</code>, <code>token.text</code>, <code>token.is_alpha</code>, <code>token.is_punct</code>, <code>token.like_num</code>… They refer to the entry in the vocabulary and don’t depend on the token’s context.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入对应语言类 Note: Some language tokenizers require external dependencies. </span></span><br><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese   <span class="comment"># https://spacy.io/usage/models 查看lang后面对应的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建nlp实例</span></span><br><span class="line">nlp = Chinese() 	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nlp对象处理一段文本并生成doc实例		</span></span><br><span class="line"><span class="comment"># When you call nlp on a string, spaCy first tokenizes the text and creates a document object.	  </span></span><br><span class="line">doc = nlp(<span class="string">&quot;这是一个句子。&quot;</span>) <span class="comment"># 底层调用 __call__方法					</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:  <span class="comment"># 遍历doc实例中的token							</span></span><br><span class="line">    print(token.text)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">一个</span></span><br><span class="line"><span class="string">句子</span></span><br><span class="line"><span class="string">。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引获得某一个token</span></span><br><span class="line">specific_token = doc[<span class="number">1</span>]	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片获得doc片段					</span></span><br><span class="line">span = doc[<span class="number">1</span>:<span class="number">3</span>]								</span><br><span class="line"></span><br><span class="line"><span class="comment"># token的一些属性</span></span><br><span class="line">doc = nlp(<span class="string">&quot;我花了20¥买了一个汉堡包。&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Index:   &quot;</span>, [token.i <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;Text:    &quot;</span>, [token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;is_alpha:&quot;</span>, [token.is_alpha <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;is_punct:&quot;</span>, [token.is_punct <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;like_num:&quot;</span>, [token.like_num <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Index:    [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="string">Text:     [&#x27;我花&#x27;, &#x27;了&#x27;, &#x27;20&#x27;, &#x27;¥&#x27;, &#x27;买&#x27;, &#x27;了&#x27;, &#x27;一个&#x27;, &#x27;汉堡包&#x27;, &#x27;。&#x27;]</span></span><br><span class="line"><span class="string">is_alpha: [True, True, False, False, True, True, True, True, False]</span></span><br><span class="line"><span class="string">is_punct: [False, False, False, False, False, False, False, False, True]</span></span><br><span class="line"><span class="string">like_num: [False, False, True, False, False, False, False, False, False]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计模型"><a href="#统计模型" class="headerlink" title="统计模型"></a>统计模型</h3><p>来源: Models are trained on large datasets of labeled example texts.<br>作用: 词性标注 (Part-of-speech tags), 依存关系解析 (Syntactic dependencies), 命名实体识别 (Named entities)<br>优化: Can be updated with more examples to fine-tune predictions</p>
<h4 id="模型包"><a href="#模型包" class="headerlink" title="模型包"></a>模型包</h4><p>spaCy提供了很多预训练好的模型包，可以使用<code>spacy download</code>进行下载 <a href="https://spacy.io/usage/models">https://spacy.io/usage/models</a></p>
<p>The package provides </p>
<ul>
<li>binary weights that enable spaCy to make predictions;</li>
<li>vocabulary, and meta information to tell spaCy which language class to use;</li>
<li>how to configure the processing pipeline;</li>
</ul>
<p>导入模型包和通过初始化语言类的nlp实例区别？</p>
<ul>
<li>spacy.lang.xxx中包含其实是特定语言的代码和规则，包括停用词，数字之类,简单认为就是最基础的一些规则</li>
<li>模型包是建立在已经对大量的标记数据进行训练后得到的统计模型，简单认为是基于spacy.lang.xxx中某一种语言最基础规则之上,对大量数据进行训练学习得到的更多规则</li>
</ul>
<h4 id="词性标注-Part-of-speech-tags"><a href="#词性标注-Part-of-speech-tags" class="headerlink" title="词性标注 (Part-of-speech tags)"></a>词性标注 (Part-of-speech tags)</h4><p>通过标注每一个token的词性，为后于文本处理提供基础保证，<code>.pos_</code>属性返回词性标注的结果</p>
<h4 id="依存关系解析-Syntactic-dependencies"><a href="#依存关系解析-Syntactic-dependencies" class="headerlink" title="依存关系解析 (Syntactic dependencies)"></a>依存关系解析 (Syntactic dependencies)</h4><p>由于已经对于token做了词性标注，由此可以进一步来进行词与词之间的关系的预测。比如一个词是某一个句子或者物体的主语。<code>.dep_</code>属性返回预测的依存关系标注,<code>.head</code>属性返回当前token的parent token(也就是依存的那一个token)</p>
<p>关于依存关系:<br>20世纪70年代，Robinson提出依存语法中关于依存关系的四条公理：</p>
<ul>
<li>一个句子中只有一个成分是独立的；</li>
<li>其它成分直接依存于某一成分；</li>
<li>任何一个成分都不能依存与两个或两个以上的成分；</li>
<li>如果A成分直接依存于B成分，而C成分在句中位于A和B之间，那么C或者直接依存于B，或者直接依存于A和B之间的某一成分；</li>
</ul>
<p>依存结构是加标签的有向图，箭头从中心词指向从属，具体来说，箭头是从head指向child,举个例子： I love you,中 I 依存于 love,所以会有一条有向边从love指向I<br><img src="/image/dependency_scapy.png"></p>
<p>常用的依存标签：<br>root:  中心词,一般为动词<br>nsubj: nominal subject,名词性主语<br>dobj:  direct object, 直接宾语<br>prep: 介词<br>pobj: 介词宾语<br>cc: 连词<br>compound: 复合词<br>advmod: 状语<br>det: 限定词<br>amod: 形容词修饰语</p>
<h4 id="命名实体识别-Named-entities"><a href="#命名实体识别-Named-entities" class="headerlink" title="命名实体识别 (Named entities)"></a>命名实体识别 (Named entities)</h4><p><code>doc.ents</code>读取模型预测出的所有命名实体,例如Bill Gates,使用<code>.label_</code>属性打印出实体标签，例如Person</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m spacy download zh_core_web_sm </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_md&quot;</span>)  <span class="comment"># load a model package by name and returns an nlp object.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;I love you!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the tokens</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    <span class="comment"># Print the text and the predicted part-of-speech tag</span></span><br><span class="line">    print(token.text, token.pos_)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I PRON</span></span><br><span class="line"><span class="string">love VERB</span></span><br><span class="line"><span class="string">you PRON</span></span><br><span class="line"><span class="string">! PUNCT</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.pos_, token.dep_, token.head.text)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I PRON nsubj love</span></span><br><span class="line"><span class="string">love VERB ROOT love</span></span><br><span class="line"><span class="string">you PRON dobj love</span></span><br><span class="line"><span class="string">! PUNCT punct love</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Apple is looking at buying U.K. startup for $1 billion&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the predicted entities</span></span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    <span class="comment"># Print the entity text and its label</span></span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Microsoft Corporation is an American multinational technology company with headquarters in Redmond, Washington.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the predicted entities</span></span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    <span class="comment"># Print the entity text and its label</span></span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Microsoft Corporation ORG</span></span><br><span class="line"><span class="string">American NORP</span></span><br><span class="line"><span class="string">Redmond GPE</span></span><br><span class="line"><span class="string">Washington GPE</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get quick definitions of the most common tags and labels.</span></span><br><span class="line">spacy.explain(<span class="string">&#x27;NORP&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Nationalities or religious or political groups&#x27;</span></span><br></pre></td></tr></table></figure>


<h4 id="基于规则的匹配抽取"><a href="#基于规则的匹配抽取" class="headerlink" title="基于规则的匹配抽取"></a>基于规则的匹配抽取</h4><p>使用预训练模型的缺陷：模型的预测是否正确取决于训练数据和处理的文本，如果处理的文本中许多规则没有被模型包含，则预测的精度不会很高。<br>解决方案: 使用预训练的模型 + 添加相应的规则</p>
<p>Match patterns</p>
<ul>
<li>Lists of dictionaries, one per token  [{},{},{}]</li>
<li>Match exact token texts</li>
<li>Match lexical attributes</li>
<li>Match any token attributes</li>
</ul>
<p>Match step:</p>
<ol>
<li>Import the <code>Matcher</code> from <code>spacy.matcher</code>.</li>
<li>Initialize it with the <code>nlp</code> object’s shared <code>vocab</code>.</li>
<li>Create patterns</li>
<li>Use the <code>matcher.add</code> to add the pattern to the matcher.</li>
<li>Call the matcher on the <code>doc</code> and store the result in the variable matches.</li>
<li>Iterate over the matches and get the matched span from the <code>start</code> to the <code>end</code> index.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> spacy.matcher <span class="keyword">import</span> Matcher <span class="comment"># # Import the Matcher</span></span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_md&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the matcher with the shared vocab</span></span><br><span class="line">matcher = Matcher(nlp.vocab)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the pattern to the matcher</span></span><br><span class="line">pattern = [&#123;<span class="string">&quot;TEXT&quot;</span>: <span class="string">&quot;iPhone&quot;</span>&#125;, &#123;<span class="string">&quot;TEXT&quot;</span>: <span class="string">&quot;X&quot;</span>&#125;]</span><br><span class="line">matcher.add(<span class="string">&quot;IPHONE_PATTERN&quot;</span>, <span class="literal">None</span>, pattern)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process some text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Upcoming iPhone X release date leaked&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the matcher on the doc</span></span><br><span class="line">matches = matcher(doc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the matches</span></span><br><span class="line"><span class="keyword">for</span> match_id, start, end <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="comment"># Get the matched span</span></span><br><span class="line">    matched_span = doc[start:end]</span><br><span class="line">    print(matched_span.text)</span><br><span class="line"><span class="string">&#x27;iPhone X&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;!&quot;&#125;	Negation: match 0 times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;?&quot;&#125;	Optional: match 0 or 1 times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;+&quot;&#125;	Match 1 or more times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;*&quot;&#125;	Match 0 or more times</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>




]]></content>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
</search>
