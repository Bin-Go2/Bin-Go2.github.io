<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-二叉树</title>
    <url>/2020/09/17/Algorithm-binarytree/</url>
    <content><![CDATA[<h2 id="二叉树的一些思想"><a href="#二叉树的一些思想" class="headerlink" title="二叉树的一些思想"></a>二叉树的一些思想</h2><ul>
<li>前序遍历(preOrder)  root-&gt;left-&gt;right </li>
<li>中序遍历(inOrder)    left-&gt; root-&gt;right 二叉搜索树中，其遍历结果为有序数组</li>
<li>后序遍历(postOrder) left-&gt;right-&gt;root </li>
<li>广度优先搜索(BFS)</li>
<li>深度优先搜索(DFS)</li>
<li>递归(Recursion)，根据要求选择使用前序，中序，后序的递归框架来解决问题</li>
</ul>
<h4 id="897-递增顺序查找树"><a href="#897-递增顺序查找树" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 思路1: 中序遍历形成有序列表 + 重新生成树</span></span><br><span class="line"><span class="comment"># 思路2: 使用递归,改变树形状，不生成新的树</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        dfs(root.left)</span><br><span class="line">        <span class="comment">### 对根节点的操作 ###</span></span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        self.cur.right = root</span><br><span class="line">        self.cur = root</span><br><span class="line">        <span class="comment">###################</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">    res = self.cur = TreeNode(<span class="literal">None</span>)</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res.right</span><br></pre></td></tr></table></figure>

<h4 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode-cn.com/problems/invert-binary-tree/">226. 翻转二叉树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">invertTree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">    <span class="comment"># 先序遍历  （后序遍历也可）</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="comment">### 对根节点的操作 ###</span></span><br><span class="line">    root.left,root.right = root.right,root.left</span><br><span class="line">    <span class="comment">### 对根节点的操作 ###</span></span><br><span class="line">    root.left = self.invertTree(root.left)  </span><br><span class="line">    root.right = self.invertTree(root.right)</span><br><span class="line">    <span class="comment"># 函数返回时就表示当前这个节点，以及它的左右子树都已经交换完了       </span></span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="617-合并二叉树"><a href="#617-合并二叉树" class="headerlink" title="617. 合并二叉树"></a><a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">617. 合并二叉树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTrees</span>(<span class="params">self, t1: TreeNode, t2: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> (t1 <span class="keyword">and</span> t2): <span class="comment"># 不能用 if not t1 and not t2</span></span><br><span class="line">        <span class="keyword">return</span> t1 <span class="keyword">if</span> t1 <span class="keyword">else</span> t2</span><br><span class="line">    t1.val+=t2.val</span><br><span class="line">    <span class="comment">#########################</span></span><br><span class="line">    t1.left = self.mergeTrees(t1.left,t2.left) </span><br><span class="line">    t1.right = self.mergeTrees(t1.right,t2.right)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> t1</span><br></pre></td></tr></table></figure>

<h4 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938. 二叉搜索树的范围和"></a><a href="https://leetcode-cn.com/problems/range-sum-of-bst/">938. 二叉搜索树的范围和</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rangeSumBST</span>(<span class="params">self, root: TreeNode, L: int, R: int</span>) -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    self.res = <span class="number">0</span> <span class="comment"># 需要使用一个全局变量进行结果的保存</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root,L,R</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">        <span class="keyword">if</span> L&lt;= root.val &lt;=R:</span><br><span class="line">            self.res+=root.val</span><br><span class="line">        <span class="comment">#########################</span></span><br><span class="line">        dfs(root.left,L,R)</span><br><span class="line">        dfs(root.right,L,R)</span><br><span class="line"></span><br><span class="line">    dfs(root,L,R)</span><br><span class="line">    <span class="keyword">return</span> self.res</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: TreeNode</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># 后序遍历</span></span><br><span class="line">    <span class="keyword">return</span> max(self.maxDepth(root.left),self.maxDepth(root.right)) +<span class="number">1</span></span><br><span class="line">    <span class="comment"># 也可以使用BFS得到高度</span></span><br></pre></td></tr></table></figure>

<h4 id="590-N叉树的后序遍历-前序遍历"><a href="#590-N叉树的后序遍历-前序遍历" class="headerlink" title="590. N叉树的后序遍历/前序遍历"></a><a href="https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal/">590. N叉树的后序遍历</a>/<a href="https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal/">前序遍历</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; List[int]:</span></span><br><span class="line">    self.res = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">helper</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> root.children:</span><br><span class="line">            helper(child)</span><br><span class="line">        <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">        self.res.append(root.val)</span><br><span class="line">        <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">    helper(root)</span><br><span class="line">    <span class="keyword">return</span> self.res</span><br></pre></td></tr></table></figure>

<h4 id="700-二叉搜索树中的搜索"><a href="#700-二叉搜索树中的搜索" class="headerlink" title="700. 二叉搜索树中的搜索"></a><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree/">700. 二叉搜索树中的搜索</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchBST</span>(<span class="params">self, root: TreeNode, val: int</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> </span><br><span class="line">    <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">    <span class="keyword">if</span> root.val == val:</span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line">    <span class="comment">#########################</span></span><br><span class="line">    <span class="keyword">if</span> root.val &lt; val:</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.right,val) <span class="comment"># 记住需要return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> self.searchBST(root.left,val)</span><br></pre></td></tr></table></figure>

<h4 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortedArrayToBST</span>(<span class="params">self, nums: List[int]</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="comment">###### 对根节点的操作 #####</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">0</span> : <span class="keyword">return</span> </span><br><span class="line">    mid = len(nums)//<span class="number">2</span></span><br><span class="line">    root = TreeNode(nums[mid])</span><br><span class="line">    <span class="comment">##########################</span></span><br><span class="line">    root.left = self.sortedArrayToBST(nums[:mid])</span><br><span class="line">    root.right = self.sortedArrayToBST(nums[mid+<span class="number">1</span>:])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="897-递增顺序查找树-1"><a href="#897-递增顺序查找树-1" class="headerlink" title="897. 递增顺序查找树"></a><a href="https://leetcode-cn.com/problems/increasing-order-search-tree/">897. 递增顺序查找树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">increasingBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dfs</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        dfs(root.left)</span><br><span class="line">        <span class="comment">### 对根节点的操作 #####</span></span><br><span class="line">        root.left = <span class="literal">None</span></span><br><span class="line">        self.cur.right = root</span><br><span class="line">        self.cur = root</span><br><span class="line">        <span class="comment">#####################</span></span><br><span class="line">        dfs(root.right)</span><br><span class="line">    res = self.cur = TreeNode(<span class="literal">None</span>)</span><br><span class="line">    dfs(root)</span><br><span class="line">    <span class="keyword">return</span> res.right</span><br></pre></td></tr></table></figure>

<h4 id="559-N叉树的最大深度"><a href="#559-N叉树的最大深度" class="headerlink" title="559. N叉树的最大深度"></a><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree/">559. N叉树的最大深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">self, root: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; int:</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span>  <span class="number">0</span>   </span><br><span class="line">    <span class="keyword">return</span> max([self.maxDepth(i) <span class="keyword">for</span> i <span class="keyword">in</span>  root.children]+[<span class="number">0</span>])+<span class="number">1</span> <span class="comment"># 注意需要 +[0] =&gt; 没有0的话会报错: max() arg is an empty sequence</span></span><br></pre></td></tr></table></figure>

<h4 id="剑指-Offer-68-II-二叉树的最近公共祖先"><a href="#剑指-Offer-68-II-二叉树的最近公共祖先" class="headerlink" title="剑指 Offer 68 - II. 二叉树的最近公共祖先"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">剑指 Offer 68 - II. 二叉树的最近公共祖先</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: TreeNode, p: TreeNode, q: TreeNode</span>) -&gt; TreeNode:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root <span class="keyword">or</span> p == root <span class="keyword">or</span> q == root: <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">    left = self.lowestCommonAncestor(root.left,p,q)</span><br><span class="line">    right = self.lowestCommonAncestor(root.right,p,q)</span><br><span class="line">    <span class="comment">### 对根节点的操作 #####</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> left <span class="keyword">and</span> <span class="keyword">not</span> right: <span class="keyword">return</span>  <span class="comment"># 左右子树均为空</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> left: <span class="keyword">return</span> right        <span class="comment"># 右空，左不空</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="keyword">not</span> right:<span class="keyword">return</span> left         <span class="comment"># 左空，右不空</span></span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> root                  <span class="comment"># 左右均不空</span></span><br><span class="line">    <span class="comment">### 对根节点的操作 #####</span></span><br></pre></td></tr></table></figure>

<h4 id="637-二叉树的层平均值"><a href="#637-二叉树的层平均值" class="headerlink" title="637. 二叉树的层平均值"></a><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637. 二叉树的层平均值</a></h4>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-剑指Offer</title>
    <url>/2020/09/05/Algorithm-jianzhioffer/</url>
    <content><![CDATA[<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span>(<span class="params">s,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>

<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    n &gt; <span class="number">1</span> <span class="keyword">and</span> sumNums(n<span class="number">-1</span>) <span class="comment"># n=1 终止递归的需求，可通过短路效应实现</span></span><br><span class="line">    res += n </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">    fre_dict=&#123;&#125; <span class="comment"># 使用字典</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        fre_dict[i] = fre_dict.get(i,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> fre_dict[i]&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 另一种思路 ，排序 找nums[i] == nums[i-1]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span>(<span class="params">nums</span>):</span> </span><br><span class="line">    tmp_res = <span class="number">0</span>     </span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_res = tmp_res ^ i  <span class="comment"># 假设需要的结果为为a和b 那么tmp_res = a^b  note: a^a = 0 </span></span><br><span class="line">    <span class="comment"># 将数组分成两部分 一部分只包含a  另一部分只包含b</span></span><br><span class="line">    pivot = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> tmp_res&amp;pivot ==<span class="number">0</span>:</span><br><span class="line">        pivot = pivot&lt;&lt;<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i &amp;pivot:</span><br><span class="line">            a = a^i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b^i</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">  <span class="comment"># 1.数学 (sum(set(nums))*3-sum(nums))//2  2.字典思路 3. 位运算</span></span><br><span class="line">  <span class="comment"># a^a = 0  a^0 = a 位运算</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>): <span class="comment"># 1 &lt;= nums[i] &lt; 2^31限制</span></span><br><span class="line">        idx = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 0001   0010   0010</span></span><br><span class="line">        count = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; idx !=<span class="number">0</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count%<span class="number">3</span> ==<span class="number">1</span>: <span class="comment"># 表明唯一的那个数在这一位上为1</span></span><br><span class="line">            res = res|idx</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br><span class="line"><span class="comment"># 非递归方法： BFS 获得层数即二叉树的深度</span></span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 遍历统计链表长度，倒是第k个节点便是顺数n-k个节点</span></span><br><span class="line">    <span class="comment"># 快慢指针思路</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># 快指针先走k步</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 递归出口</span></span><br><span class="line">    root.left, root.right = self.mirrorTree(root.right),self.mirrorTree(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 非递归方法： BFS 对每一层进行迭代 </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 对每一层的每一个节点进行遍历</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        tmp_left, tmp_right =node.left, node.right</span><br><span class="line">        <span class="keyword">if</span> tmp_left:</span><br><span class="line">            queue.append(tmp_left)</span><br><span class="line">            node.right = tmp_left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> tmp_right:</span><br><span class="line">            queue.append(tmp_right)</span><br><span class="line">            node.left = tmp_right  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.left = <span class="literal">None</span>              </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n) ]</span><br></pre></td></tr></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">head</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        res.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]    </span><br><span class="line"><span class="comment"># 递归解法 return reversePrint(head.next) + [head.val] if head else []</span></span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    cur,pre = head,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp </span><br><span class="line">    <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">root, k</span>):</span></span><br><span class="line">    <span class="comment"># 中序遍历 获得有序数组后返回第k个大的数字。 中序遍历： 左子树 + root + 右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            res+=(traverse(root.left)) <span class="comment"># 注意不能使用append  否则会形成一个嵌套列表 </span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            res+=(traverse(root.right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表####"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a>####</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1,l2</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 新建一个链表，依次插入合适的节点</span></span><br><span class="line">    cur = dummy = ListNode(<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.next, l1 = l1, l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.next, l2 = l2, l2.next</span><br><span class="line">        cur = cur.next</span><br><span class="line">    cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 使用递归进行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 位运算 n&amp;(n−1)  二进制数字n最右边的 1 变成 0 ，其余不变。</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        n &amp;= n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># n&amp;1 =1 =&gt; n 二进制 最右一位 为 1 ；n&amp;1 = 0 =&gt; n 二进制 最右一位 为 0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n&amp;<span class="number">1</span></span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.A,self.B = [],[]</span><br><span class="line">       <span class="comment"># A 负责入队  B负责出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

<h4 id="复杂链表的复制-待定"><a href="#复杂链表的复制-待定" class="headerlink" title="复杂链表的复制 ##待定"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a> ##待定</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">head</span>):</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先-待定"><a href="#二叉树的最近公共祖先-待定" class="headerlink" title="二叉树的最近公共祖先##待定"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a>##待定</h4><h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="comment"># 滑动窗口解决</span></span><br><span class="line">    nums = list(range(<span class="number">1</span>,(target//<span class="number">2</span>+<span class="number">2</span>))) <span class="comment"># 候选的最大值不会超高target/2 +1</span></span><br><span class="line">    res = []</span><br><span class="line">    start_window,total = <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> end_window <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        total += nums[end_window]</span><br><span class="line">        <span class="keyword">while</span> total&gt;=target:</span><br><span class="line">            <span class="keyword">if</span> total == target:  <span class="comment"># 窗口和 = target =&gt;当前窗口加入结果 窗口起点右移</span></span><br><span class="line">                res.append(nums[start_window:end_window+<span class="number">1</span>])</span><br><span class="line">            total -= nums[start_window]</span><br><span class="line">            start_window+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    root = preorder[<span class="number">0</span>]</span><br><span class="line">    pos = inorder.index(root)</span><br><span class="line"></span><br><span class="line">    binary_tree = TreeNode(root)</span><br><span class="line">    binary_tree.left = self.buildTree(preorder[<span class="number">1</span>:pos+<span class="number">1</span>],inorder[:pos])</span><br><span class="line">    binary_tree.right = self.buildTree(preorder[pos+<span class="number">1</span>:],inorder[pos+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> binary_tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从上到下打印二叉树-I"><a href="#从上到下打印二叉树-I" class="headerlink" title="从上到下打印二叉树 I"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 I</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>


<h4 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># BFS 层序遍历 使用队列实现</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        cur_level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            cur_level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(cur_level)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>

<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxValue</span>(<span class="params">grid</span>):</span> </span><br><span class="line">    <span class="comment"># 二维dp  grid[i][j] = max(grid[i][j - 1], grid[i - 1][j]) +  grid[i][j]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>: grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">    <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]  <span class="comment">#  排序后取中间的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Boyer-Moore 投票法 O(n)</span></span><br><span class="line">    res = nums[<span class="number">0</span>]</span><br><span class="line">    cal = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> cal ==<span class="number">0</span>: </span><br><span class="line">            res = i</span><br><span class="line">        <span class="keyword">if</span> i == res:</span><br><span class="line">            cal+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cal-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums,target</span>):</span>  </span><br><span class="line">    left, right = <span class="number">0</span>,len(nums)<span class="number">-1</span> <span class="comment"># 使用双指针 空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">        sums = nums[left]+nums[right]</span><br><span class="line">        <span class="keyword">if</span> sums&lt;target:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sums&gt;target:</span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums[left],nums[right]]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 带条件的动态规划</span></span><br><span class="line">    dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        n2, n3, n5 = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">        dp[i] = min(n2, n3, n5)</span><br><span class="line">        <span class="keyword">if</span> dp[i] == n2: a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n3: b += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n5: c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">    left,right = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">    <span class="comment"># 保证nums[left]奇数,nums[right]为偶数</span></span><br><span class="line">        <span class="keyword">if</span> nums[left]%<span class="number">2</span>==<span class="number">1</span>:  </span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[right]%<span class="number">2</span> ==<span class="number">1</span>:</span><br><span class="line">                nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">prices</span>):</span></span><br><span class="line">    <span class="comment"># opt[i] = max(opt[i-1],prices[i]-min(prices[:i])) 动态规划转移方程</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    min_price = prices[<span class="number">0</span>] <span class="comment"># 存储当天前最低的股票</span></span><br><span class="line">    opt = [<span class="number">0</span>]*len(prices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i]&lt;min_price:</span><br><span class="line">            min_price = prices[i]</span><br><span class="line">        opt[i] = max(opt[i<span class="number">-1</span>],prices[i]-min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> opt[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="把字符串转换成整数"><a href="#把字符串转换成整数" class="headerlink" title="把字符串转换成整数"></a><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">把字符串转换成整数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strToInt</span>(<span class="params">self, str: str</span>) -&gt; int:</span></span><br><span class="line">    sign,res = <span class="number">1</span>,<span class="number">0</span></span><br><span class="line">    str = str.strip()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 情况1: 字符串只有空格</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> str: <span class="keyword">return</span> <span class="number">0</span> </span><br><span class="line">    <span class="comment"># 首先判断第一个字符</span></span><br><span class="line">    <span class="keyword">if</span> str[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span> : sign = <span class="number">-1</span></span><br><span class="line">    <span class="keyword">elif</span> str[<span class="number">0</span>] == <span class="string">&#x27;+&#x27;</span>: sign = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> <span class="string">&#x27;0&#x27;</span>&lt;=str[<span class="number">0</span>]&lt;=<span class="string">&#x27;9&#x27;</span>:res = res*<span class="number">10</span> + int(str[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">return</span> res </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> str[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&#x27;0&#x27;</span>&lt;=i&lt;=<span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">            res = res*<span class="number">10</span> + ord(i) - ord(<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> sign&gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> res <span class="keyword">if</span> res &lt; <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span> <span class="keyword">else</span> <span class="number">2</span>**<span class="number">31</span><span class="number">-1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> res*sign <span class="keyword">if</span> res*sign &gt; <span class="number">-2</span>**<span class="number">31</span> <span class="keyword">else</span>  <span class="number">-2</span>**<span class="number">31</span></span><br></pre></td></tr></table></figure>

<h4 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">数值的整数次方</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span>(<span class="params">self, x: float, n: int</span>) -&gt; float:</span></span><br><span class="line">    <span class="comment">### 分治思想</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">1</span> <span class="comment"># base </span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span> : x,n = <span class="number">1</span>/x,-n  </span><br><span class="line">    <span class="keyword">if</span> n %<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> self.myPow(x,n//<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x * self.myPow(x,n//<span class="number">2</span>)**<span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="数字序列中某一位的数字"><a href="#数字序列中某一位的数字" class="headerlink" title="数字序列中某一位的数字"></a><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">数字序列中某一位的数字</a></h4><h4 id="0～n-1中缺失的数字"><a href="#0～n-1中缺失的数字" class="headerlink" title="0～n-1中缺失的数字"></a><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof/">0～n-1中缺失的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[int]</span>) -&gt; int:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] != i:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> len(nums) <span class="comment"># 类似 [0]这样的情况，缺失的为1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 排序数组中的搜索问题，首先想到&quot;二分&quot;解决。</span></span><br><span class="line">    xxx</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-滑动窗口</title>
    <url>/2020/09/09/Algorithm-sliding-window/</url>
    <content><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><u>连续</u>子数组</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据要求，找到第一个满足条件的窗口</li>
<li>调整窗口(右移/左移)使其继续满足要求，并进行重复</li>
<li>得到最合适的窗口即为答案</li>
</ul>
<h3 id="Leetcode例题"><a href="#Leetcode例题" class="headerlink" title="Leetcode例题"></a>Leetcode例题</h3><h5 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_start,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        char = s[window_end]</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> dic <span class="keyword">and</span> dic[char]&gt;=window_start: <span class="comment"># 注意这里的第二个条件dic[char]&gt;=window_start！！ 起到一个覆盖的作用</span></span><br><span class="line">            window_start = dic[char] +<span class="number">1</span></span><br><span class="line">        dic[char] = window_end</span><br><span class="line">        width = window_end-window_start+<span class="number">1</span></span><br><span class="line">        res = max(width,res)</span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h5 id="大小为-K-且平均值大于等于阈值的子数组数目"><a href="#大小为-K-且平均值大于等于阈值的子数组数目" class="headerlink" title="大小为 K 且平均值大于等于阈值的子数组数目"></a><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">大小为 K 且平均值大于等于阈值的子数组数目</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numOfSubarrays</span>(<span class="params">arr,k,threshold</span>):</span></span><br><span class="line">    <span class="keyword">if</span> arr == [] <span class="keyword">or</span> len(arr)&lt;k:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_sum,window_start,res = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    temp = threshold*k</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        window_sum+=arr[window_end]</span><br><span class="line">        <span class="keyword">if</span> window_end&gt;=k<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> window_sum &gt;=temp:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            window_sum-=arr[window_start]</span><br><span class="line">            window_start+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h5><h5 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></h5><h5 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h5>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Blocking and Relational Entity Resolution</title>
    <url>/2020/10/11/Blocking-and-Relational-Entity-Resolution/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>Entity Resolution 主要分成如下四个</p>
<ol>
<li>Coreference     文本与文本之间找同一个entity</li>
<li>Entity linking  文本与KG中找对应entity     -&gt; Integrating New Candidates </li>
<li>Deduplication   一个KG之间的聚类              -&gt; Merging  Ambiguous Entities</li>
<li>Record linkage  两个不同KG之间entity的对应  -&gt; Combining KGs</li>
</ol>
<h1 id="Blocking"><a href="#Blocking" class="headerlink" title="Blocking"></a>Blocking</h1><h2 id="为什么需要Blocking-gt-reduce-the-number-of-comparisons"><a href="#为什么需要Blocking-gt-reduce-the-number-of-comparisons" class="headerlink" title="为什么需要Blocking -&gt; reduce the number of comparisons"></a>为什么需要Blocking -&gt; reduce the number of comparisons</h2><ul>
<li>Comparing each entity with all other entities is too computationally demanding –&gt; O(N^2)</li>
<li>If partition entities into N ”blocks”– O(N)</li>
<li>Make only within block comparisons, so if largest block is log N in size –&gt; O(NlogN^2)</li>
</ul>
<h2 id="Blocking-分类"><a href="#Blocking-分类" class="headerlink" title="Blocking 分类"></a>Blocking 分类</h2><p>Disjoint Blocking: Each mention appears in one block.(=Set Partition)<br>Non-disjoint Blocking: Mentions can appear in more than one block. </p>
<h2 id="Blocking一般的情形"><a href="#Blocking一般的情形" class="headerlink" title="Blocking一般的情形"></a>Blocking一般的情形</h2><p><img src="/image/blocking_scenario.png"></p>
<h2 id="Blocking衡量指标"><a href="#Blocking衡量指标" class="headerlink" title="Blocking衡量指标"></a>Blocking衡量指标</h2><ul>
<li>Efficiency: Blue/Grey</li>
<li>Recall:     Green/Yellow</li>
<li>Precision:  Green/Blue</li>
<li>Max Canopy Size: 包含mentions个数最多的block的mentions个数</li>
</ul>
<h2 id="Blocking方式"><a href="#Blocking方式" class="headerlink" title="Blocking方式"></a>Blocking方式</h2><h3 id="Feature-based-blocking-keys"><a href="#Feature-based-blocking-keys" class="headerlink" title="Feature-based blocking keys"></a>Feature-based blocking keys</h3><p>思想: 通过选择实体的某一个或者多个属性作为key，将包含该key的实体放在同一个block下，对每个block再进行entity resolution</p>
<p>例子:<br>First three characters of last name<br>City + State + Zip<br>Character or Token n-grams<br>Minimum infrequent n-grams</p>
<h3 id="Clustering-or-sorting"><a href="#Clustering-or-sorting" class="headerlink" title="Clustering or sorting"></a>Clustering or sorting</h3><ol>
<li><p>Sorted Neighborhood Blocking<br>思想: 通过选择实体的某一个属性,根据该属性对实体进行排序，使用一个窗格，窗格内的实体划分到一个block中去</p>
</li>
<li><p>Canopy Clustering<br>Input: Mentions M, x is an entity<br>d(x,y), a distance metric<br>thresholds T1 &gt; T2</p>
</li>
</ol>
<p>思想:</p>
<ol>
<li>Pick a random element x from M</li>
<li>Create new canopy Cx using mentions y s.t. d(x,y) &lt; T1</li>
<li>Delete all mentions y from M s.t. d(x,y) &lt; T2 </li>
<li>Return to Step 1 if M is not empty</li>
</ol>
<p><img src="/image/canopy_cluster.png"></p>
<h3 id="Hashing"><a href="#Hashing" class="headerlink" title="Hashing"></a>Hashing</h3><p>思想:</p>
<ol>
<li>Each block Ci is associated with a hash key hi.</li>
<li>Mention x is hashed to Ci if hash(x) = hi.</li>
<li>Within a block, all pairs are compared.</li>
<li>Each hash function results in disjoint blocks.</li>
</ol>
<h2 id="Blocking选择考虑因素"><a href="#Blocking选择考虑因素" class="headerlink" title="Blocking选择考虑因素"></a>Blocking选择考虑因素</h2><ul>
<li>key的选择:learn the keys, or use expert knowledge/heuristics?</li>
<li>Schema awareness: what do we know about the attributes?</li>
<li>Key type: exact equality, similarity-based, or hybrid 相同的key放到一个block还是相似放一个block</li>
<li>Redundancy: entity in one or multiple blocks? Does matching in multiple blocks increase the match probability</li>
<li>Frequency limits</li>
<li>Adaptive keys based on frequency</li>
<li>Learning keys based on data </li>
</ul>
<h2 id="Learning-to-block"><a href="#Learning-to-block" class="headerlink" title="Learning to block"></a>Learning to block</h2><p>Using one or more blocking predicates may be insufficient =&gt; Construct blocking predicates by combining simple predicates</p>
<h1 id="Collective-Relational-Entity-Resolution"><a href="#Collective-Relational-Entity-Resolution" class="headerlink" title="Collective Relational Entity Resolution"></a>Collective Relational Entity Resolution</h1><h2 id="策略-Using-PSL-for-collective-KG-ER"><a href="#策略-Using-PSL-for-collective-KG-ER" class="headerlink" title="策略: Using PSL for collective KG ER"></a>策略: Using PSL for collective KG ER</h2><ol>
<li>Encode ER dependencies in a set of rules</li>
<li>Use soft-logic values to capture similarities</li>
<li>Use logic to capture the constraints</li>
</ol>
]]></content>
      <tags>
        <tag>Knowledge Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>CSCI570-outline</title>
    <url>/2020/09/08/CSCI570-outline/</url>
    <content><![CDATA[<p>hello world!</p>
]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Commands Often Used</title>
    <url>/2020/09/05/Commands%20Often%20Used/</url>
    <content><![CDATA[<h2 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1. hexo"></a>1. hexo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&#x27;post&#x27;</span> <span class="comment"># Create a new post</span></span><br><span class="line">$ hexo g  <span class="comment"># Generate static files  </span></span><br><span class="line">$ hexo s  <span class="comment"># Run server</span></span><br><span class="line">$ hexo d  <span class="comment"># Deploy to remote sites</span></span><br><span class="line">$ hexo clean <span class="comment"># Remove cache file (db.json) and static files (public)</span></span><br></pre></td></tr></table></figure>


<h2 id="2-Conda"><a href="#2-Conda" class="headerlink" title="2. Conda"></a>2. Conda</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ conda create -n env_name python=<span class="number">3.6</span>   <span class="comment"># 创建虚拟环境</span></span><br><span class="line">$ conda activate env_name   <span class="comment"># 激活虚拟环境</span></span><br><span class="line">$ conda deactivate env_name <span class="comment"># 退出虚拟环境</span></span><br><span class="line">$ conda env list <span class="comment"># 查看conda环境</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于切换jupyter中服务内核(在jupyter notebook中使用不同的环境)</span></span><br><span class="line"><span class="number">1.</span> $ conda activate env_name </span><br><span class="line"><span class="number">2.</span> $ conda install ipykernel</span><br><span class="line"><span class="number">3.</span> $ python -m ipykernel install --name env_name</span><br><span class="line"><span class="number">4.</span> $ jupyter notebook  新建python,出现对应环境提示</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改环境名称（无法修改，只能复制+删除）</span></span><br><span class="line"><span class="number">1.</span> $ conda create -n new_env --clone old_env</span><br><span class="line"><span class="number">2.</span> $ conda remove -n old_env --all</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-Linux"><a href="#3-Linux" class="headerlink" title="3. Linux"></a>3. Linux</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ du -h --max-depth&#x3D;1  dir-name # 查看文件夹大小</span><br><span class="line">$ du -sh * #查看当前文件以及文件夹的大小</span><br><span class="line">$ htop  # 查看系统cpu、mem使用情况 </span><br><span class="line">$ htop -u username #查看某个用户的进程使用</span><br><span class="line">$ cpulimit -l 50 -p pid #限制某个进程的cpu使用率为50%</span><br><span class="line">$ rclone # 本地文件与google drive连接的桥梁</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="4-CPU信息"><a href="#4-CPU信息" class="headerlink" title="4. CPU信息"></a>4. CPU信息</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac:</span><br><span class="line">$ sysctl machdep.cpu #所有信息</span><br><span class="line">$ sysctl -n machdep.cpu.brand_string    # CPU型号</span><br><span class="line">$ sysctl -n machdep.cpu.core_count      # CPU核心数</span><br><span class="line">$ sysctl -n machdep.cpu.thread_count    # 线程数</span><br><span class="line"></span><br><span class="line">Linux</span><br><span class="line">$ grep &#39;physical id&#39; &#x2F;proc&#x2F;cpuinfo | sort -u  # 查看物理cpu个数</span><br><span class="line">$ grep &#39;core id&#39; &#x2F;proc&#x2F;cpuinfo | sort -u | wc -l  # 核心数量</span><br><span class="line">$ grep &#39;processor&#39; &#x2F;proc&#x2F;cpuinfo | sort -u | wc -l  # 线程数</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Efficiency</category>
      </categories>
      <tags>
        <tag>Commands</tag>
      </tags>
  </entry>
  <entry>
    <title>DSCI-553-outline</title>
    <url>/2020/10/23/DSCI-553-outline/</url>
    <content><![CDATA[<h2 id="DSCI551-Foundations-and-Applications-of-Data-Mining"><a href="#DSCI551-Foundations-and-Applications-of-Data-Mining" class="headerlink" title="DSCI551 - Foundations and Applications of Data Mining"></a>DSCI551 - Foundations and Applications of Data Mining</h2><h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1:"></a>Part1:</h3><!-- <a href="/2020/09/06/Firebase-rest-web-api/" title="Firebase rest &amp; web api">Firebase rest &amp; web api</a>  -->

<h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2:"></a>Part2:</h3><!-- <a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a>  -->


<h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3: "></a>Part3: <a href="/2020/10/23/Social-network/" title="社交网络">社交网络</a></h3><!-- <a href="/2020/09/10/File-Systems/" title="File systems">File systems</a>  -->




]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>DSCI551 outline</title>
    <url>/2020/09/06/DSCI551-outline/</url>
    <content><![CDATA[<h2 id="DSCI551-Foundations-of-Data-Management"><a href="#DSCI551-Foundations-of-Data-Management" class="headerlink" title="DSCI551 - Foundations of Data Management"></a>DSCI551 - Foundations of Data Management</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/09/06/Firebase-rest-web-api/" title="Firebase rest &amp; web api">Firebase rest &amp; web api</a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2020/09/08/Storage-systems/" title="Storage systems">Storage systems</a></h3><h3 id="-3"><a href="#-3" class="headerlink" title=""></a><a href="/2020/09/10/File-Systems/" title="File systems">File systems</a></h3><h3 id="-4"><a href="#-4" class="headerlink" title=""></a><a href="/2020/09/11/NFS/" title="Network File System">Network File System</a></h3><h3 id="-5"><a href="#-5" class="headerlink" title=""></a><a href="/2020/09/18/File-Format/" title="XML">XML</a></h3>]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>DSCI558-outline</title>
    <url>/2020/10/11/DSCI558-outline/</url>
    <content><![CDATA[<h2 id="DSCI558-Building-Knowledge-Graphs"><a href="#DSCI558-Building-Knowledge-Graphs" class="headerlink" title="DSCI558 - Building Knowledge Graphs"></a>DSCI558 - Building Knowledge Graphs</h2><h3 id="待续"><a href="#待续" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-1"><a href="#待续-1" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-2"><a href="#待续-2" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-3"><a href="#待续-3" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-4"><a href="#待续-4" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-5"><a href="#待续-5" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-6"><a href="#待续-6" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-7"><a href="#待续-7" class="headerlink" title="待续"></a>待续</h3><h3 id="待续-8"><a href="#待续-8" class="headerlink" title="待续"></a>待续</h3><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/10/11/Probabilistic-Models-for-KG-Construction/" title="PSL">PSL</a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2020/10/11/Blocking-and-Relational-Entity-Resolution/" title="Blocking and Relational Entity Resolution">Blocking and Relational Entity Resolution</a></h3>]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>XML</title>
    <url>/2020/09/18/File-Format/</url>
    <content><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><ul>
<li>XML：eXtensible Markup Language</li>
<li>XML is a syntax (serialization format) for data sharing and exchange on the Web<ul>
<li>Can translate <em>any</em> data to XML</li>
<li>Can ship XML over the Web (HTTP)</li>
<li>Can input XML into any application</li>
</ul>
</li>
</ul>
<h3 id="XML-Structure"><a href="#XML-Structure" class="headerlink" title="XML Structure"></a>XML Structure</h3><p><img src="/image/XML.png"></p>
<ul>
<li>XML is self-describing</li>
<li>Schema elements become part of the data(关系型数据记录中schema不算是内容，但是在xml中节点自身也携带内容信息) </li>
<li>XML is semi-structured <ul>
<li>missing attributes  (could be represented as null in table)</li>
<li>repeated attributes (impossible in table)</li>
<li>Attributes with different types in different objects</li>
<li>Nested structures</li>
<li>Heterogeneous contents</li>
</ul>
</li>
<li>an XML document has a single root element</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">example:</span><br><span class="line"><span class="tag">&lt;<span class="name">bib</span>&gt;</span></span><br><span class="line">...</span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">price</span>=<span class="string">&quot;35&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisher</span>&gt;</span>Addison-Wesley<span class="tag">&lt;/<span class="name">publisher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Serge Abiteboul<span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">first-name</span>&gt;</span>Rick<span class="tag">&lt;/<span class="name">first-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">last-name</span>&gt;</span>Hull<span class="tag">&lt;/<span class="name">last-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">author</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span> <span class="attr">age</span>=<span class="string">&quot;20&quot;</span>&gt;</span>Victor Vianu<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Foundations of Databases<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>1995<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>38.8<span class="tag">&lt;/<span class="name">price</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">price</span>=<span class="string">&quot;55&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">publisher</span>&gt;</span>Freeman<span class="tag">&lt;/<span class="name">publisher</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Jeffrey D. Ullman<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Principles of Database and Knowledge Base Systems<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">year</span>&gt;</span>1998<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span> </span><br><span class="line">... </span><br><span class="line"><span class="tag">&lt;/<span class="name">bib</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Querying-XML-Data"><a href="#Querying-XML-Data" class="headerlink" title="Querying XML Data"></a>Querying XML Data</h3><h4 id="XPath-simple-navigation-through-the-tree"><a href="#XPath-simple-navigation-through-the-tree" class="headerlink" title="XPath: simple navigation through the tree"></a>XPath: simple navigation through the tree</h4><p><img src="/image/xpath.png"></p>
<h3 id="lxml"><a href="#lxml" class="headerlink" title="lxml"></a>lxml</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ pip install lxml</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line">f = open(<span class="string">&#x27;bibs.xml&#x27;</span>)</span><br><span class="line">tree = etree.parse(f)</span><br><span class="line">print(etree.tostring(tree, pretty_print=<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> tree.xpath(<span class="string">&quot;//author&quot;</span>): </span><br><span class="line">    print(etree.tostring(element))</span><br><span class="line">    print(element.tag, element.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Python</tag>
        <tag>File Format</tag>
      </tags>
  </entry>
  <entry>
    <title>File systems</title>
    <url>/2020/09/10/File-Systems/</url>
    <content><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><blockquote>
<p>A filesystem is the methods and data structures that an operating system uses to keep track of files on a disk or partition; that is, the way the files are organized on the disk.</p>
</blockquote>
<ul>
<li>File content stored in blocks on storage device</li>
<li>Files are organized into directories (folders)<br><img src="/image/file-system.png"></li>
</ul>
<h3 id="Detail-about-file"><a href="#Detail-about-file" class="headerlink" title="Detail about file"></a>Detail about file</h3><h4 id="File-descriptor"><a href="#File-descriptor" class="headerlink" title="File descriptor"></a>File descriptor</h4><p>A file descriptor is a number that uniquely identifies an open file in a computer’s operating system. It describes a data resource, and how that resource may be accessed.<br>简单的说，根据Linux一切皆文件的概念来看，当进程打开或者创建文件的时候，内核会向进程返回一个数字，这个数字就是文件描述符，所有执行I/O操作的系统调用都通过文件描述符来进行。</p>
<h4 id="Hard-link-and-symbolic-link-soft-link"><a href="#Hard-link-and-symbolic-link-soft-link" class="headerlink" title="Hard link and symbolic link/soft link"></a>Hard link and symbolic link/soft link</h4><p>A hard link is essentially a synced carbon copy of a file that refers directly to the inode of a file. Symbolic links on the other hand refer directly to the file which refers to the inode, a shortcut.</p>
<p><img src="/image/hard-soft-link.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ln a.txt b.txt    <span class="comment"># 创建硬链接 - 副本</span></span><br><span class="line">$ ln -s a.txt c.txt <span class="comment"># 创建软链接 - 替身（快捷方式）</span></span><br><span class="line">$ unlink c.txt      <span class="comment"># 取消链接</span></span><br></pre></td></tr></table></figure>

<h4 id="File-permission-mode"><a href="#File-permission-mode" class="headerlink" title="File permission mode"></a>File permission mode</h4><p>3种模式  r:read w:write x:execute<br>3种身份: user group others<br>3*3 = 27 种访问权限<br>rw-r–r– =&gt; 110 (owner permission) 100 (group) 100 (others)<br>可以使用<code>chomod</code> 来进行权限的修改</p>
<h4 id="Inode"><a href="#Inode" class="headerlink" title="Inode"></a>Inode</h4><p>The inode (index node) is a data structure in a Unix-style file system that describes a file-system object such as a file or a directory. <a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">更多inode细节</a> </p>
<ul>
<li>Stores metadata/attributes about the file ( use <code>stat file</code> to check the metadata )</li>
<li>Also stores locations of blocks holding the content of the file</li>
</ul>
<h5 id="metadata"><a href="#metadata" class="headerlink" title="metadata"></a>metadata</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">More details about the file metadata</span><br><span class="line"></span><br><span class="line">struct stat &#123;</span><br><span class="line">dev_t st_dev; &#x2F;* ID of device containing file *&#x2F;</span><br><span class="line">ino_t st_ino; &#x2F;* inode number *&#x2F;</span><br><span class="line">mode_t st_mode; &#x2F;* protection *&#x2F;</span><br><span class="line">nlink_t st_nlink; &#x2F;* number of (hard) links *&#x2F;</span><br><span class="line">uid_t st_uid; &#x2F;* user ID of owner *&#x2F;</span><br><span class="line">gid_t st_gid; &#x2F;* group ID of owner *&#x2F;</span><br><span class="line">dev_t st_rdev; &#x2F;* device ID (if special device file, e.g., &#x2F;etc&#x2F;tty) *&#x2F; </span><br><span class="line">off_t st_size; &#x2F;* total size, in bytes *&#x2F;</span><br><span class="line">blksize_t st_blksize; &#x2F;* blocksize for filesystem I&#x2F;O *&#x2F;</span><br><span class="line">blkcnt_t st_blocks; &#x2F;* number of blocks allocated *&#x2F;</span><br><span class="line">time_t st_atime; &#x2F;* last time file content was accessed *&#x2F;</span><br><span class="line">time_t st_mtime; &#x2F;* last time file content was modified *&#x2F; </span><br><span class="line">time_t st_ctime; &#x2F;* last time inode was changed *&#x2F;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">time_t st_atime; &#x2F;* last time file content was accessed *&#x2F; 关于这一项的思考：</span><br><span class="line">这一项表明了不论对文件是什么操作，都会进行inode的修改，有的时候为了提升I&#x2F;O性能，会在挂载文件系统的时候指定“noatime,nodiratime”参数，意味着当访问一个文件和目录的时候，access time都不会更新</span><br><span class="line">可以通过 cat &#x2F;etc&#x2F;fstab 查看具体信息</span><br></pre></td></tr></table></figure>
<p><img src="/image/inode.png"></p>
<h5 id="locations-of-data"><a href="#locations-of-data" class="headerlink" title="locations of data"></a>locations of data</h5><p>An inode has:</p>
<ul>
<li>A number of direct pointers,each points to a data block<br>example: a inode has 8 pointers, each pointer points to a 4K block, then this inode is enogh for 8*4K = 32KB size of file</li>
<li>Also has a slot for indirect pointer : a pointer points to a data block storing direct pointers<br>example: 1 block’s size: 4KB, pointer size: 4 bytes, then a block can hold 1024 pointers =&gt; Now file can have (8 + 1024) blocks , enough for 4MB size of file</li>
</ul>
<p>How to store larger files? - Multi-level index</p>
<ul>
<li>Pointers may be organized into multiple levels (double,triple,…n times) </li>
</ul>
<p><img src="/image/double-indirect-pointers.png"><br>1 direct pointer =&gt; 1 block (4KB)<br>1 indirect pointer =&gt; 2^10 direct pointer  =  2^10*4KB  = 4MB<br>1 double indirect pointer =&gt; 2^10 indirect pointers =&gt; 2^20 direct pointers  =&gt; 2^20*4KB = 4GB</p>
<h4 id="Organization-of-blocks"><a href="#Organization-of-blocks" class="headerlink" title="Organization of blocks"></a>Organization of blocks</h4><p>Assumption:(便于理解，做些假设)</p>
<ol>
<li>Disk consists of a list of blocks and they are array-based.(other forms:Tree-based, e.g., SGI XFS -Blocks are organized into variable-length extents)</li>
<li>a disk with 64 blocks<ul>
<li>4KB/block   =&gt;文件系统的最小单元</li>
<li>512B/sector =&gt;存储系统的最小单元 </li>
<li>so there are 2^12/2^9 = 2^3 = 8 sectors/block and capacity of disk = 64 * 4KB = 256KB</li>
</ul>
</li>
</ol>
<p>Structure about these blocks: </p>
<ol>
<li>Data region (56 blocks (#8-63))</li>
<li>Inode table (5 blocks #3 – #7) 元数据+文件内容地址<ul>
<li>assume 256 bytes/inode 5 blocks, 4KB/block</li>
<li>=&gt; 80 inodes total  (4KB/256B * 5)</li>
<li>=&gt; File system can store at most 80 files</li>
</ul>
</li>
<li>Bitmaps (#1, #2)  a vector of bits, 0 for free (inode/block), 1 for in-use<ul>
<li>Inode bitmap (imap):keep track of which inodes in the inode table are available  (这里4KB一个block 1byte=8bit，所以一个block的话最多以存储80K个inode的状态)</li>
<li>Data bitmap (dmap):keep track of which blocks in data region are available</li>
</ul>
</li>
<li>Superblock(#0): Track where i/d blocks and inode table are; Indicate type of FS &amp; inumber of its root dir; Will be read first when file system is mounted</li>
</ol>
<p><img src="/image/block_info_fs.png"></p>
<h4 id="Inumber"><a href="#Inumber" class="headerlink" title="Inumber"></a>Inumber</h4><p>Each inode is identified by a number: Low-level number of file name<br>Can figure out location of inode from inumber 通过inumber可以寻址到其代表的inode所在的sector<br>Location:  ⌊(inodeStartAddress + inumber ∗ inode size)/sector size⌋</p>
<p>example: inumber = 32<br>Address:12K+32*256=20K<br>Sector #: 20K/512 = 40<br><img src="/image/inumber.png"></p>
<p>总结inumber,inode,data一句话来说就是inumber =&gt; inode =&gt; data</p>
<h3 id="Detail-about-directory"><a href="#Detail-about-directory" class="headerlink" title="Detail about directory"></a>Detail about directory</h3><h4 id="Basic-1"><a href="#Basic-1" class="headerlink" title="Basic"></a>Basic</h4><ul>
<li>Directory itself stored as a file</li>
<li>For each file in the directory, it stores:<ul>
<li>name, inumber, record length, string length</li>
</ul>
</li>
<li>If file is deleted (using rm command) or a name is unlinked (using unlink command),then inumber in its directory entry set to 0 (reserved for empty entry)<ul>
<li>File is finally deleted when its last (hard) link is removed<br><img src="/image/directory.png"></li>
</ul>
</li>
</ul>
<h4 id="Storing-a-directory"><a href="#Storing-a-directory" class="headerlink" title="Storing a directory"></a>Storing a directory</h4><ul>
<li>Also as a file with its own inode + data block</li>
<li>inode:<ul>
<li>file type: directory (instead of regular file)</li>
<li>pointer to block(s) in data region storing directory entries</li>
</ul>
</li>
</ul>
<h3 id="Operations-on-file"><a href="#Operations-on-file" class="headerlink" title="Operations on file"></a>Operations on file</h3><ul>
<li>Create: open(), write()</li>
<li>Read:  open(),read(), lseek()</li>
<li>Update: write(), lseek()</li>
<li>Delete: unlink()</li>
</ul>
<p>Note: 这些函数都是操作系统自带提供的系统调用函数</p>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul>
<li>User interface via GUI or touch command in Linux</li>
<li>Implementation, e.g., via a C program with a system call: open()</li>
<li>open() returns a file descriptor. Reserved fds: stdin 0, stdout, 1, stderr 2</li>
<li>After getting the file descriptor of file, start read() <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fd &#x3D; open(&quot;&#x2F;foo&#x2F;bar&quot;, O_RDONLY)</span><br><span class="line">- Need to locate inode of the file &quot;&#x2F;foo&#x2F;bar&quot;</span><br><span class="line">- Assume inumber of root, say 2, is known (e.g., when the file system is mounted)</span><br><span class="line"></span><br><span class="line">step1: read inode and content of &#x2F;  (2 reads)</span><br><span class="line">- Look for &quot;foo&quot; in &#x2F; -&gt; foo&#39;s inumber</span><br><span class="line"></span><br><span class="line">step2: read inode and content of &#x2F;foo (2 reads)</span><br><span class="line">- Look for &quot;bar&quot; in &#x2F;foo -&gt; bar&#39;s inumber</span><br><span class="line"></span><br><span class="line">step3: read inode of &#x2F;foo&#x2F;bar (1 read)</span><br><span class="line">– Permission check + allocate file descriptor</span><br><span class="line"></span><br><span class="line">open-file table per process(维护这些进程，系统有一个 open-file table)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">read(fd, buffer, size)</span><br><span class="line">– Note fd is maintained in per-process open-file table</span><br><span class="line">– Table translates fd -&gt; inumber of file</span><br><span class="line"></span><br><span class="line">step1: consult bar&#39;s inode to locate a block</span><br><span class="line">step2: read the block</span><br><span class="line">step3: update inode with newest file access time</span><br><span class="line">step4: update open-file table with new offset</span><br><span class="line">step5: repeat above steps until done(with reading data of given size)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img src="/image/read.png"></li>
</ul>
<p>I/O cost for open(): 5 reads<br>I/O cost for reading a block: 2 reads + 1 write</p>
<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int fd &#x3D; open(&quot;&#x2F;foo&#x2F;bar&quot;, O_WRONLY)</span><br><span class="line">– Or int fd &#x3D; create((&quot;&#x2F;foo&#x2F;bar&quot;)</span><br><span class="line">– Assume bar is a new file under foo</span><br><span class="line"></span><br><span class="line">step1: read&#39;&#x2F;&#39;inode &amp; content -&gt; obtain foo&#39;s inumber</span><br><span class="line">step2: read&#39;&#x2F;foo&#39;inode &amp; content -&gt; check if bar exists</span><br><span class="line">step3: read imap,to find a free inode for bar</span><br><span class="line">step4: update imap,setting 1 for allocated inode</span><br><span class="line">step5: write bar&#39;s inode</span><br><span class="line">step6: update foo&#39;s content block  - adding an entry for bar</span><br><span class="line">step7: update foo&#39;s inode  -update its modification time</span><br><span class="line"></span><br><span class="line">write(fd, buffer, size)</span><br><span class="line">step1: read inode of bar(by looking up its inumber in the open-file table)</span><br><span class="line">step2: allocate new data block – read and write bmap</span><br><span class="line">step3: write to data block of bar</span><br><span class="line">step4: update bar node - new modification time, add pointer to block</span><br></pre></td></tr></table></figure>
<p><img src="/image/write.png"></p>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase rest &amp; web api</title>
    <url>/2020/09/06/Firebase-rest-web-api/</url>
    <content><![CDATA[<h2 id="Firebase-概述（BaaS）"><a href="#Firebase-概述（BaaS）" class="headerlink" title="Firebase 概述（BaaS）"></a>Firebase 概述（BaaS）</h2><p>Firebase谷歌的一款应用后台服务。借助Firebase，应用开发者们可以快速搭建应用后台。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ol>
<li>Firebase (realtime) database: Manage <strong>JSON</strong> documents + Real-time <strong>syncing</strong> data between users and devices</li>
<li>Firebase (cloud) storage: Store images, photos, videos</li>
<li>Firebase (user) authentication: Support sign in using Google, Facebook</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>Create a Firebase account: first use Google account,then go to Firebase console: <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a></li>
<li>Click on “Add project”  to create a Firebase project</li>
<li>Add Firebase to your web app</li>
<li>any other interesting operation …</li>
</ol>
<h3 id="关于-Realtime-database"><a href="#关于-Realtime-database" class="headerlink" title="关于 Realtime database"></a>关于 Realtime database</h3><ul>
<li>Data in JSON(Javascript Object Notation) format  <a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a> </li>
<li>When creating a real-time database, we should open up the access to allow us to read and write the data.</li>
<li>There are some difference between storing style from JSON file and Firebase real-time database<ol>
<li>JSON文件中的array元素在Realtime database下以object的形式存在，object对应的key为数组元素的索引</li>
<li>JSON文件可以保存value为null的键值对，Realtime database则会忽略这一对键值对<br><img src="/image/firebase1.png"></li>
</ol>
</li>
</ul>
<h2 id="Firebase-REST-API"><a href="#Firebase-REST-API" class="headerlink" title="Firebase REST API"></a>Firebase REST API</h2><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p> REST：Representation State Transfer，表现层状态转移<br> 一句话解释的话就是:通过URL定位资源，用HTTP动词（GET, POST, PUT, DELETE)描述操作从而用来实现前后端数据传输的协议。</p>
<h3 id="命令行进行http数据传输：curl"><a href="#命令行进行http数据传输：curl" class="headerlink" title="命令行进行http数据传输：curl"></a>命令行进行http数据传输：curl</h3><p>  For command operation, it’s convenient to use <strong>curl</strong> (Command line tool for data transfer)<br>  curl详细使用：<a href="https://itbilu.com/linux/man/4yZ9qH_7X.html">https://itbilu.com/linux/man/4yZ9qH_7X.html</a><br>  注意，curl大小写敏感，请求的命令参数均为大写字符</p>
<h3 id="curl例子-CRUD"><a href="#curl例子-CRUD" class="headerlink" title="curl例子 - CRUD"></a>curl例子 - CRUD</h3><p>  PUT &amp; POST (C), GET (R), PATCH (U) ,DELETE (D)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JSON tree:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;isMarried&quot;</span>: false,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="string">&quot;height_cm&quot;</span>: <span class="number">167.6</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;streetAddress&quot;</span>: <span class="string">&quot;22nd Street&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;NY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postalCode&quot;</span>: <span class="string">&quot;10021-3100&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;phoneNumbers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;212 555-1234&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;office&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;646 555-4567&quot;</span>,</span><br><span class="line">      <span class="string">&quot;xyz&quot;</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;spouse&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;scores&quot;</span>: [<span class="number">8.5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GET-get-the-specific-resource"><a href="#GET-get-the-specific-resource" class="headerlink" title="GET: get the specific resource"></a>GET: get the specific resource</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;address&#x2F;city.json&#39;   return: &quot;New York&quot;%  </span><br><span class="line">-X   可以省略 直接 curl GET url; GET  可以省略 直接 curl url</span><br><span class="line"></span><br><span class="line">$ curl &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;phoneNumbers&#x2F;0.json&#39; #refer to arr element by index</span><br><span class="line">return:&#123;&quot;number&quot;:&quot;212 555-1234&quot;,&quot;type&quot;:&quot;home&quot;&#125;%  </span><br></pre></td></tr></table></figure>

<h4 id="PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”"><a href="#PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”" class="headerlink" title="PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)"></a>PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add if node not exists (could add embedded nodes) - 添加数据</span><br><span class="line">Overwrite if node already has value               - 重写数据</span><br><span class="line"></span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Mary&quot;&#39;  # 注意引号</span><br><span class="line"></span><br><span class="line">#This will add a new node &quot;country&quot; (assuming it does not exist yet) </span><br><span class="line">#and a child of this node with key &quot;province&quot; and content: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;</span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country&#x2F;province.json&#39; -d &#39;&#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#39; </span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="POST-add-new-value-to-a-given-node"><a href="#POST-add-new-value-to-a-given-node" class="headerlink" title="POST: add new value to a given node"></a>POST: add new value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Automatically generates a new key &amp; then stores the value for the new key</span><br><span class="line">由于对于添加的数据，其自动生成一个key，所以保证不会重写数据(In contrast, PUT will simply overwrite the key)</span><br><span class="line"> </span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d  &#39;&quot;Anhui&quot;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="PATCH-upsert-a-value-to-a-given-node"><a href="#PATCH-upsert-a-value-to-a-given-node" class="headerlink" title="PATCH:  upsert a value to a given node"></a>PATCH:  upsert a value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Performs the update if value already exists  -更新节点</span><br><span class="line">Otherwise, it inserts the new value          -插入新节点</span><br><span class="line">PATCH本质上是一个深度搜索符合节点的条件进行更新或者添加)</span><br><span class="line"></span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Hubei&quot;&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处:相比于PUT（对于已经存在的节点进行全局的修改），本质上来说PATCH实现的是对该节点的局部更新</span><br><span class="line">注意:当需要更新的节点没有子节点（仅仅是一个key-value格式），无法使用PATCH，因为 -d 参数后需要传入键值对的格式</span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # fail</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &quot;Invalid data; couldn&#39;t parse JSON object. Are you sending a JSON object with valid key names?&quot;</span><br><span class="line">&#125;</span><br><span class="line">curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # success</span><br></pre></td></tr></table></figure>
<h4 id="DELETE-delete-a-node"><a href="#DELETE-delete-a-node" class="headerlink" title="DELETE:  delete a node"></a>DELETE:  delete a node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X DELETE &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39;</span><br></pre></td></tr></table></figure>

<h4 id="从数据增加、减少上对PUT、PATCH和POST进行比较"><a href="#从数据增加、减少上对PUT、PATCH和POST进行比较" class="headerlink" title="从数据增加、减少上对PUT、PATCH和POST进行比较"></a>从数据增加、减少上对PUT、PATCH和POST进行比较</h4><p>PUT可能造成数据的增加（添加新节点下的value）和减少（overwrite整个节点导致其内嵌的节点被删除）；<br>PATCH可能造成数据的增加（添加新节点下的value)和减少（update节点的用更少的数据去取代原先的数据）<br>POST一定会造成数据的增加（因为会自动加上key）；</p>
<h4 id="data-querying-by-RESful-API"><a href="#data-querying-by-RESful-API" class="headerlink" title="data querying by RESful API"></a>data querying by RESful API</h4><ul>
<li>orderBy=”$key”  </li>
<li>orderBy=”<path-to-child-key>“</li>
<li>orderBy=”$value”  需要在Realtime database的Rules先声明</li>
<li>startAt/endAt</li>
<li>equalTo</li>
<li>limitToFirst/limitToLast </li>
</ul>
<p>Specified in database rules:<br><a href="https://firebase.google.com/docs/database/security/indexing-data">https://firebase.google.com/docs/database/security/indexing-data</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;equalTo&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;startAt&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$value&quot;&#39;</span><br><span class="line"></span><br><span class="line">Orders ascendingly:</span><br><span class="line">null -&gt; false -&gt;true -&gt; number -&gt; string -&gt; object</span><br></pre></td></tr></table></figure>


<h2 id="REST-API-in-Python"><a href="#REST-API-in-Python" class="headerlink" title="REST API in Python"></a>REST API in Python</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;xxxx&#39;</span><br><span class="line">data &#x3D; &#39;xxx&#39;</span><br><span class="line"></span><br><span class="line">requests.get(url) </span><br><span class="line">requests.put(url, data)</span><br><span class="line">requests.patch(url, data)</span><br><span class="line">requests.delete(url)</span><br><span class="line">requests.post(url, data)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Commands</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-BigGraph 从实体嵌入到边得分</title>
    <url>/2020/10/23/From-embedding-to-scores/</url>
    <content><![CDATA[<h1 id="From-entity-embeddings-to-edge-scores"><a href="#From-entity-embeddings-to-edge-scores" class="headerlink" title="From entity embeddings to edge scores"></a>From entity embeddings to edge scores</h1><p>The goal of training is to embed each entity in ℝ^D so that the embeddings of two entities are a good proxy to predict whether there is a relation of a certain type between them.<br>训练的目的是将每个实体嵌入到D维的向量空间中，以便两个实体的嵌入可以很好地预测它们之间是否存在某种类型的关系。</p>
<p>To be more precise, the goal is to learn an embedding for each entity and a function for each relation type that takes two entity embeddings and assigns them a score, with the goal of having positive relations achieve higher scores than negative ones.<br>更确切地说，PBG的目标是学习每个实体的嵌入和每种关系类型的函数，该函数接受两个实体嵌入并为其分配一个分数，目的是使正面关系比负面关系获得更高的分数。</p>
<blockquote>
<p>key point: 实体-&gt;D维向量 关系-&gt;函数</p>
</blockquote>
<p>All the edges provided in the training set are considered positive instances. In order to perform training, a set of negative edges is needed as well. These are not provided by the user but instead generated by the system during training (Negative sampling), usually by fixing the left-hand side entity and the relation type and sampling a new right-hand side entity, or vice versa. This sampling scheme makes sense for large sparse graphs, where there is a low probability that edges generated this way are true positives edges in the graph.<br>训练集中提供的所有边被视为正例。为了执行训练，还需要一些负边（负样本）。 这些不是由用户提供的，而是由系统在训练过程中生成的（负采样），通常是通过固定左侧实体和关系类型并采样新的右侧实体，反之亦然。 对于大的稀疏图，这种采样方案是有意义的，因为在这样的情况下，以这种方式生成的边为图中的正例的可能性很小。</p>
<p>A priori, entity embeddings could take any value in ℝ^D. Although, in some cases (for example when restricting them to be within a certain ball, or when comparing them using cosine distance), their “angle” will have greater importance than their norm.<br>先验实体嵌入可以在D维空间中取任何值。但是在某些情况下（例如，当将它们限制在某个球内或使用余弦距离进行比较时），它们的“角度”比范数更具有意义。</p>
<p>Per-relation scoring functions, however, must be expressible in a specific form (the most common functions in the literature can be converted to such a representation). In the current implementation, they are only allowed to transform the embedding of one of the two sides, which is then compared to the un-transformed embedding of the other side using a generic symmetric comparator function, which is the same for all relations. Formally, for left- and right-hand side entities 𝑥 and 𝑦 respectively, and for a relation type 𝑟, the score is:<center>𝑓𝑟(𝜃𝑥,𝜃𝑦)=𝑐(𝜃𝑥,𝑔𝑟(𝜃𝑦))</center><br>where 𝜃𝑥 and 𝜃𝑦 are the embeddings of 𝑥 and 𝑦 respectively, 𝑓𝑟 is the scoring function for 𝑟, 𝑔𝑟 is the operator for 𝑟 and 𝑐 is the comparator.</p>
<!-- $$f_{r}\left(\theta_{x}, \theta_{y}\right)=c\left(\theta_{x}, g_{r}\left(\theta_{y}\right)\right) -->
<p>然而，对于每个关系的得分计算函数，必须以特定的形式表现出来（文献中最常见的函数可以转换为这种表示形式）。在目前的实现中，只允许对一侧的实体进行嵌入转换，通过使用通用的对称比较器将其与另一侧未转换的实体嵌入进行比较，这样的操作对于所有的关系类型都是一样的。形式上，分别对于左侧和右侧实体𝑥和,，以及对于关系类型𝑟，得分为：𝑓𝑟(𝜃𝑥,𝜃𝑦)=𝑐(𝜃𝑥,𝑔𝑟(𝜃𝑦)), 其中，𝜃𝑥和𝜃𝑦分别是𝑥和𝑦的嵌入，𝑓𝑟是关系𝑟的评分函数，𝑔𝑟是关系r的算子，𝑐是比较器。</p>
<p>Under “normal” circumstances (the so-called “standard” relations mode) the operator is solely applied to the right-hand side entities. This is not the case when using dynamic relations. Applying the operator to both sides would oftentimes be redundant. Also, preferring one side over the other allows to break the symmetry and capture the direction of the edge.<br>在通常情况下(或者说是标准的关系模式中)，算子仅仅是适用于右侧实体。但是在PBG的动态关系中则不是这样。通常，将算子运用在两侧的实体嵌入上是多余的，并且倾向于选择某一侧的举动可以很好的打破对称性并且捕捉到边的方向。</p>
<h2 id="Embeddings"><a href="#Embeddings" class="headerlink" title="Embeddings"></a>Embeddings</h2><p>Embeddings live in a 𝐷-dimensional real space, where 𝐷 is determined by the dimension configuration parameter.<br>嵌入是一个𝐷维实空间的向量，其中𝐷的大小由配置参数确定。</p>
<p>Normally, each entity has its own embedding, which is entirely independent from any other entity’s embedding. When using featurized entities however this works differently, and an entity’s embedding will be the average of the embeddings of its features.<br>通常的，每一个实体都有属于自己的完全和其他实体嵌入独立的嵌入。然而，当使用特征化的实体时，情况有所不同。此时实体的嵌入为其特征嵌入的平均值。</p>
<p>If the max_norm configuration parameter is set, embeddings will be projected onto the unit ball with radius max_norm after each parameter update.<br>如果设置了max_norm配置参数，则在每次更新参数后，嵌入将会被投影到半径为max_norm的单位球上。</p>
<blockquote>
<p>🤔️ 暂时没看懂。</p>
</blockquote>
<p>To add a new type of embedding, one needs to subclass the torchbiggraph.model.AbstractEmbedding class.<br>要添加一种新型的嵌入，需要将torchbiggraph.model.AbstractEmbedding类作为子类。</p>
<blockquote>
<p>🤔️ 暂时没看懂。</p>
</blockquote>
<h2 id="Global-embeddings"><a href="#Global-embeddings" class="headerlink" title="Global embeddings"></a>Global embeddings</h2><p>When the global_emb configuration option is active, each entity’s embedding will be translated by a vector that is specific to each entity type (and that is learned at the same time as the embeddings).<br>当global_emb配置参数设置为True的时候，每个实体的嵌入将会被表示成一个向量，该向量对于每种实体类型都是特定的。（并且该向量是与嵌入同时学习得到的）</p>
<blockquote>
<p>🤔️ 暂时没看懂。</p>
</blockquote>
<h2 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a>Operators</h2><p>The operators that are currently provided are:<br>• none, no-op, which leaves the embeddings unchanged;<br>• translation, which adds to the embedding a vector of the same dimension;<br>• diagonal, which multiplies each dimension by a different coefficient (equivalent to multiplying by a diagonal matrix);<br>• linear, which applies a linear map, i.e., multiplies by a full square matrix<br>• affine, which applies a affine transformation, i.e., linear followed by translation.<br>• complex_diagonal, which interprets the 𝐷-dimensional real vector as a 𝐷/2-dimensional complex vector (𝐷 must be even; the first half of the vector are the real parts, the second half the imaginary parts) and then multiplies each entry by a different complex parameter, just like diagonal.<br>当前提供的算子有:<br>• 无，无操作，使嵌入保持不变；<br>• 平移算子，将相同尺寸的向量添加到嵌入中；<br>• 对角算子，将每个维度乘以不同的系数（相当于乘以对角矩阵）；<br>• 线性算子，运用一个线性映射，例如，讲嵌入和一个全方阵点乘；<br>• 仿射算子，应用仿射变换，即线性变换后再进行平移；<br>• 复对角算子，将D维实向量转化为D/2维复矢量（𝐷必须是偶数；矢量的前半部分是实数部分，后半部分是虚数部分），然后将每个项乘以不同的复数参数，就像对角算子一样。</p>
<p>All the operators’ parameters are learned during training.<br>训练过程中将学习所有算子的参数。</p>
<p>To define an additional operator, one must subclass the torchbiggraph.model.AbstractOperator class (or the torchbiggraph.model.AbstractDynamicOperator one when using dynamic relations; their docstrings explain what must be implemented) and decorate it with the torchbiggraph.model.OPERATORS.register_as() decorator (respectively the torchbiggraph.model.DYNAMIC_OPERATORS.register_as() one), specifying a new name that can then be used in the config to select that comparator. All of the above can be done inside the config file itself.<br>如果要自定义新的算子，需要实现torchbiggraph.model.AbstractOperator的子类（动态关系情况下实现torchbiggraph.model.AbstractDynamicOperator子类，docstrings解释了必须实现什么）并且在torchbiggraph.model.OPERATORS.register_as()装饰器中注册（或者torchbiggraph.model.DYNAMIC_OPERATORS.register_as() ）指定一个新名称，然后在配置中使用该名称来选择比较器。上述所有操作都可以在配置文件内部完成。</p>
<blockquote>
<p>🤔️ 暂时没看懂。</p>
</blockquote>
<h2 id="Comparators"><a href="#Comparators" class="headerlink" title="Comparators"></a>Comparators</h2><p>The available comparators are:<br>• dot, the dot-product, which computes the scalar or inner product of the two embedding vectors;<br>• cos, the cos distance, which is the cosine of the angle between the two vectors or, equivalently, the dot product divided by the product of the vectors’ norms.<br>• l2, the negative L2 distance, a.k.a. the Euclidean distance (negative because smaller distances should get higher scores).<br>• squared_l2, the negative squared L2 distance.<br>当前提供的比较器有：<br>• 点乘，计算两个实体嵌入向量的标量或内积；<br>• 余弦距离，两个实体嵌入向量的余弦夹角，或者等效的说是 dot(a,b)/(sqrt(a^2)*sqrt(a^2))<br>• 负L2距离，又称欧几里得距离（使用负的二范数是因为真正比较的是两者的相似度，较小的距离应获得更高的分数，这里的分数其实就类似于相似度)<br>• L2的负平方距离。</p>
<p>Custom comparators need to extend the torchbiggraph.model.AbstractComparator class (its docstring explains how) and decorate it with the torchbiggraph.model.COMPARATORS.register_as() decorator, specifying a new name that can then be used in the config to select that comparator. All of the above can be done inside the config file itself.<br>自定义比较器需要扩展torchbiggraph.model.AbstractComparator类（其文档字符串说明方式），并使用torchbiggraph.model.COMPARATORS.register_as（）装饰器对其进行修饰，并指定一个新名称，该名称随后可在配置中用于选择该比较器。以上所有操作均可在配置文件本身中完成。</p>
<h2 id="Bias"><a href="#Bias" class="headerlink" title="Bias"></a>Bias</h2><p>If the bias configuration key is in use, then the first coordinate of the embeddings will act as a bias in the comparator computation. This means that the comparator will be computed on the last 𝐷−1 entries of the vectors only, and then both the first entries of the two vectors will be added to the result.<br>如果bias参数在配置文件中设置为True，那么嵌入的第一个坐标将充当比较器计算中的偏置。这意味着比较器将仅在向量得第二维到第D维上进行计算，然后将两个向量的第一维都直接被添加到结果中。</p>
<h2 id="Coherent-sets-of-configuration-parameters"><a href="#Coherent-sets-of-configuration-parameters" class="headerlink" title="Coherent sets of configuration parameters"></a>Coherent sets of configuration parameters</h2><p>While the parameters described in this chapter are exposed as uncoupled knobs in the configuration file (to more closely match the implementation, and to allow for more flexible tuning), some combinations of them are more sensible than others.<br>尽管本章中描述的参数在配置文件中显示为未耦合的旋钮（为了更近似匹配实现效果，并允许更灵活的调优），但它们中的某些组合比其他组合更合理。</p>
<p>Apart from the default one, the following configuration has been found to work well: init_scale = 0.1, comparator = dot, bias = true, loss_fn = logistic, lr = 0.1.<br>除默认配置外，还发现以下配置可以正常运行：init_scale = 0.1，comparator = dot, bias = true, loss_fn = logistic, lr = 0.1。</p>
<h2 id="Interpreting-the-scores"><a href="#Interpreting-the-scores" class="headerlink" title="Interpreting the scores"></a>Interpreting the scores</h2><p>The scores will be tuned to have different meaning and become more suitable for certain applications based on the loss function used during training. Common options include ranking what other entities may be related to a given entity, determining the probability that a certain relation exists between two given entities, etc.<br>根据训练过程中使用的损失函数，得分将被调整为具有不同的含义，并且变得更适合某些特定的应用。常见选项包括对其他实体可能与给定实体相关的等级进行排名、确定两个给定实体之间存在某种关系的可能性等指标。</p>
<p>源地址：<br><a href="https://torchbiggraph.readthedocs.io/en/latest/scoring.html">https://torchbiggraph.readthedocs.io/en/latest/scoring.html</a></p>
]]></content>
      <tags>
        <tag>PyTorch-BigGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON-review</title>
    <url>/2020/09/07/JSON-review/</url>
    <content><![CDATA[<h2 id="JSON概述"><a href="#JSON概述" class="headerlink" title="JSON概述"></a>JSON概述</h2><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation)，由道格拉斯·克罗克福特构想和设计、轻量级的数据交换语言,该语言以易于让人阅读的文字为基础，用来<strong>传输由属性值或者序列性的值组成的数据对象</strong>。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式。</p>
<ul>
<li>Light-weight data exchange format<br>Much simpler than XML; Language-independent; Inspired by the syntax of JavaScript object literals</li>
<li>Some differences from JavaScript objects<br><strong>String in JSON must be double-quoted</strong>; Okay to single-quote in JavaScript (&amp; Python)</li>
<li>JSON is case-sensitive</li>
</ul>
<p>一句话表达就是，JSON是一种格式，基于文本，优于轻量，用于交换数据，由于其用文本格式的保存方式，所以一般也叫JSON字符串。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>value = string | number | object | array | true | false | null</li>
<li>object = {} | { members }<ul>
<li>members = pair | pair, members </li>
<li>pair = string : value</li>
</ul>
</li>
<li>array = [] | [ elements ]<ul>
<li>elements = value | value, elements</li>
</ul>
</li>
</ul>
<p>一般情况下，JSON大多为一个array，array里的每一个元素为一个object，object可以理解为字典<br>JSON 在线检查器:   <a href="https://www.json.cn/">https://www.json.cn/</a></p>
<h2 id="Python中使用JSON"><a href="#Python中使用JSON" class="headerlink" title="Python中使用JSON"></a>Python中使用JSON</h2><h3 id="encode-decode"><a href="#encode-decode" class="headerlink" title="encode/decode"></a>encode/decode</h3><p>JSON操作主要分为两个：</p>
<ol>
<li>encode，将Python对象转化为JSON文本，主要函数 dump( ) dumps( )</li>
<li>decode，将JSON文本转化为Python对象，主要函数 load( ) loads( )</li>
</ol>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><table>
<thead>
<tr>
<th align="center">Python</th>
<th align="center">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="center">list/tuple</td>
<td align="center">array</td>
</tr>
<tr>
<td align="center">dict</td>
<td align="center">object</td>
</tr>
<tr>
<td align="center">None</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">True</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">‘abc’</td>
<td align="center">“abc”</td>
</tr>
</tbody></table>
<p>关于Python字典转JSON文本的说明：</p>
<ul>
<li>Keys in Python can be number, string, or tuple. </li>
<li>Number is also converted to string.</li>
<li>But tuple (with two or more components) is not acceptable by dumps()/dump()</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="comment"># json库为Python自带的标准库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON encoder Python object =&gt; JSON document   </span></span><br><span class="line">json.dumps([<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="literal">True</span>, <span class="literal">None</span>])  <span class="comment"># &#x27;[3, &quot;abc&quot;, true, null]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python object =&gt; JSON file</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_file:</span><br><span class="line">    json.dump(data,out_file)</span><br><span class="line"></span><br><span class="line"><span class="comment">## JSON decoder </span></span><br><span class="line">json.loads(<span class="string">&#x27;[&quot;foo&quot;, &#123;&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]&#125;]&#x27;</span>) <span class="comment"># [&#x27;foo&#x27;, &#123;&#x27;bar&#x27;: [&#x27;baz&#x27;, None, 1.0, 2]&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON file =&gt; Python object</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">    data = json.load(in_file)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>File Format</tag>
      </tags>
  </entry>
  <entry>
    <title>ssh连接远程服务器中途断开</title>
    <url>/2020/10/23/Linux-screen/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Mac机器使用ssh操作远程服务器的途中,由于网络波动,断开连接,休眠等一系列奇葩原因导致终端<code>client_loop: send disconnect: Broken pipe</code>,<br>在这样的情况下，远程服务器也跟着掉线。</p>
<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>即使本地Mac掉线，远程服务器仍旧保持工作</p>
<h2 id="解决方式-Screen"><a href="#解决方式-Screen" class="headerlink" title="解决方式: Screen"></a>解决方式: Screen</h2><ol>
<li><p>连接远程服务器<br><code>binzhang@MacBin ~$  ssh username@servername</code></p>
</li>
<li><p>创建名为cskg的screen,  此时screen被创建，之后的代码或者各种工作在该screen下操作<br><code>[servername ~]$ screen -S cskg </code></p>
</li>
<li><p>万一本地机器掉线，重新连接远程服务器，随后使用screen -ls 查看之前创建的screen信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[servername ~]$ screen -ls  </span><br><span class="line">显示信息：</span><br><span class="line">There is a screen on:</span><br><span class="line">        157586.cskg  (Attached)</span><br><span class="line">1 Socket in &#x2F;var&#x2F;run&#x2F;screen&#x2F;xx</span><br></pre></td></tr></table></figure></li>
<li><p>使用-r回到之前服务器工作的screen<br><code>screen -r 157586</code></p>
</li>
</ol>
<h3 id="Screen常见问题"><a href="#Screen常见问题" class="headerlink" title="Screen常见问题"></a>Screen常见问题</h3><p>使用<code>screen -ls</code>, 显式当前状态为Attached，但并没有没有用户登陆该screen。screen此时正常状态应该为(Detached)使用 <code>screen -r &lt;session-id&gt;</code>无法连接，</p>
<p>解决方案:<code>screen -D  -r ＜session-id&gt;</code>,-D -r  表示先踢掉前用户，再登陆。</p>
<p>cpulimit –limit=50 -p ‘pgrep -f /nas/home/binzhang/app/anaconda3/envs/CSKG/bin/python’</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Network File System</title>
    <url>/2020/09/11/NFS/</url>
    <content><![CDATA[<h3 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h3><p>The Network File System (NFS) is a client/server application that lets a computer user view and optionally store and update files on a remote computer as though they were on the user’s own computer. NFS is a distributed file system(DFS).</p>
<h4 id="Client-server-architecture"><a href="#Client-server-architecture" class="headerlink" title="Client/server architecture"></a>Client/server architecture</h4><p><img src="/image/C-S.png"></p>
<p>Advantage</p>
<ul>
<li>Easy sharing of data across clients</li>
<li>Centralized administration</li>
<li>Security</li>
</ul>
<p>Disadvantage:</p>
<ul>
<li>Network overhead</li>
<li>More components to fail</li>
</ul>
<h3 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h3><h4 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h4><p><img src="/image/DFS.png"></p>
<h4 id="Stateless-无状态协议"><a href="#Stateless-无状态协议" class="headerlink" title="Stateless  - 无状态协议"></a>Stateless  - 无状态协议</h4><ul>
<li>Server does not keep track of states of clients<ul>
<li>Which files are currently open at which clients</li>
<li>Current position/offset of file</li>
<li>Which clients have read/cached which blocks</li>
</ul>
</li>
<li>Requests from clients must make sure:<ul>
<li>the server can deliver all the information needed to complete the requests</li>
<li>do not rely on previous requests</li>
</ul>
</li>
</ul>
<h4 id="file-handle"><a href="#file-handle" class="headerlink" title="file handle"></a>file handle</h4><ul>
<li>Volume (file system) identifier<ul>
<li>Which volume? (e.g. partition C or D if NTFS)</li>
</ul>
</li>
<li>Inode number<ul>
<li>Which file in the volume?</li>
</ul>
</li>
<li>Generation number<ul>
<li>Needed since inode number may be reused at the server (e.g., after file has been deleted by other clients)</li>
</ul>
</li>
</ul>
<p><strong>Client uses file handle to communication with server</strong><br><img src="/image/file-handle.png"></p>
<h4 id="RPC-Remote-procedure-call"><a href="#RPC-Remote-procedure-call" class="headerlink" title="RPC - Remote procedure call"></a>RPC - Remote procedure call</h4><ul>
<li>Remote server publishes a set of procedures, for example f(args)<ul>
<li>example: NFSPROC_LOOKUP for lookup file handle ,read, write, create, remove, etc.</li>
</ul>
</li>
<li>In making RPC calls,(客户端调用)<ul>
<li>Client notifies remote server of executing f &amp; sends over arguments args for f</li>
<li>Server executes f(args) =&gt; results </li>
<li>Server sends back results</li>
</ul>
</li>
</ul>
<h3 id="Operations-on-remote-file"><a href="#Operations-on-remote-file" class="headerlink" title="Operations on remote file"></a>Operations on remote file</h3><p>All CRUD operations use <u>file handle</u></p>
<h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><p><u>First obtain file handle via lookup</u></p>
<ul>
<li>File handle for the root directory may be obtained via the mount protocol</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Look up &quot;&#x2F;foo&#x2F;more&#x2F;bar.txt&quot;</span><br><span class="line">– First, use &#x2F; file handle to obtain foo&#39;s handle  </span><br><span class="line">	File handle for the root directory may be obtained via the mount protocol</span><br><span class="line">– Next, use foo&#39;s handle to obtain more&#39;s handle</span><br><span class="line">– Finally, use more&#39;s handle to obtain bar.txt handle</span><br></pre></td></tr></table></figure>

<p><u>Then use file handle to read data</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_READ(file handle, offset, count)</span><br><span class="line">- offset here is explicit</span><br><span class="line">– Return: data + file attributes</span><br><span class="line">– File attributes include modification time, useful for client-size cache validation</span><br><span class="line"></span><br><span class="line">Compared to local file system</span><br><span class="line">- n &#x3D; read(fd, buffer, size)</span><br><span class="line">– n is the number of bytes actually read</span><br></pre></td></tr></table></figure>


<h4 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h4><p><u>First obtain file handle via lookup</u></p>
<p><u>Then use file handle to write data</u></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_WRITE(file handle, offset, count, data)</span><br><span class="line">– Return: file attributes</span><br><span class="line">– Note again explicit offset is specified in the call</span><br><span class="line"></span><br><span class="line">Compared to local file system</span><br><span class="line">– n &#x3D; write(fd, buffer, size)</span><br><span class="line">– Offset is again implicit (current position)</span><br></pre></td></tr></table></figure>

<h4 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_CREATE(directory file handle, name of file in the directory, attributes)</span><br><span class="line">– Return: file handle</span><br></pre></td></tr></table></figure>

<h4 id="Remove"><a href="#Remove" class="headerlink" title="Remove"></a>Remove</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NFSPROC_REMOVE(directory file handle, name of file to be removed)</span><br><span class="line">– Return: Nothing</span><br></pre></td></tr></table></figure>

<h3 id="Failures"><a href="#Failures" class="headerlink" title="Failures"></a>Failures</h3><h4 id="Cases"><a href="#Cases" class="headerlink" title="Cases"></a>Cases</h4><p>Case1: request lost<br>Case2: Server down<br>Case3: Reply lost on way back from Sever</p>
<h3 id="More-details"><a href="#More-details" class="headerlink" title="More details"></a>More details</h3><p>学习资源: <a href="https://tools.ietf.org/html/rfc1094">https://tools.ietf.org/html/rfc1094</a></p>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-BigGraph  批准备</title>
    <url>/2020/10/27/PBG-Batch-preparation/</url>
    <content><![CDATA[<h1 id="PBG-批准备"><a href="#PBG-批准备" class="headerlink" title="PBG 批准备"></a>PBG 批准备</h1><p>This section presents how the training data is prepared and organized in batches before the loss is calculated and optimized on each of them.<br>本节介绍了如何在计算和优化损失之前如何对训练数据进行准备和组织。</p>
<p>Training proceeds by iterating over the edges, through various nested loops. The outermost one walks through so-called epochs. Each epoch is independent and essentially equivalent to every other one. Their goal is to repeat the inner loop until convergence. Each epoch visits all the edges exactly once. The number of epochs is specified in the num_epochs configuration parameter.<br>训练过程通过不断嵌套循环各条边来进行。所有边都被训练过一次叫做一个epoch，每一个epoch都是互相独立且平等的。他们的目标都是为了重复训练边最终达到收敛的效果。每一个epoch只访问每一条一次。在配置文件中的num_epochs指定epoch数目。</p>
<p>The edges are partitioned into edge sets (one for each directory of the edge_paths configuration key) and, within each epoch, the edge sets are traversed in order.<br>图中的边被划分为边集合的形式（edge_paths目录下的每个文件表示一个边集合），在每一个epoch下，这些边集合按照顺序访问遍历。</p>
<p>When iterating over an edge set, each of its buckets is first divided into equally sized chunks: each chunk spans a contiguous interval of edges (in the order they are stored in the files) and the number of chunks can be tweaked using the num_edge_chunks configuration key. The training first operates on the all the first chunks of all buckets, then on all of their second chunks, and so on.<br>当在某一个边集合上进行迭代训练的时候，每一个桶（一个边集合）首先被划分成相同大小的chunks，每一个chunk跨度连续的边间隔（按它们存储在文件中的顺序），可以在配置文件中使用num_edge_chunks来设置chunk的大小。训练首先对桶中的第一个chunk进行训练，然后对第二个，以此类推。</p>
<p>Next, the algorithm iterates over the buckets. The order in which buckets are processed depends on the value of the bucket_order configuration key. In addition to a random permutation, there are methods that try to have successive buckets share a common partition: this allows for that partition to be reused, thus allowing it to be kept in memory rather than being unloaded and another one getting loaded in its place. (In distributed mode, the various trainer processes operate on the buckets at the same time, thus the iteration is managed differently).<br>接下来，该算法迭代训练每一个桶。桶训练顺序取决于配置文件中的bucket_order。除了随机排列之外，还有一些方法尝试使连续的存储桶共享一个公共分区，也就是说允许这个共享分区被重用。通过这样其允许这这些边数据保存在内存中而不是被卸载然后被其他的边数据取代。（在分布式模式下，各种训练器进程同时在存储桶上运行训练，因此对迭代的管理不同）。</p>
<p>Once the trainer has fixed a given chunk and a certain bucket, its edges are finally loaded from disk. When evaluating during training, a subset of these edges is withheld (such subset is the same for all epochs). The remaining edges are immediately uniformly shuffled and then split into equal parts. These parts are distributed among a pool of processes, so that the training can proceed in parallel on all of them at the same time. These subprocesses are “Hogwild!” workers, which do not synchronize their computations or memory accesses. The number of such workers is determined by the workers parameter.<br>一旦训练器获得了一个给定的chunk和bucket，其chuck的边最终从磁盘上加载到内存。在训练之前，边的一部分被保留下载作为之后的评估使用。（对于所有的epoch而言，这些边是一样的），其余的边都作为训练数据，他们被均匀地混洗，然后分成相等的部分分发到进程池里进行训练。因此训练是可以在所有进程上并行运行的。这些子进程被称为“Hogwild!” worker，他们的计算和内存使用并不同步进行。worker的数目在配置文件中的worfers参数指定。</p>
<blockquote>
<p>key point: 这里worker就可以当成是进程数目，几个worker表示可以同时几个进程并行训练数据。</p>
</blockquote>
<p>The way each worker trains on its set of edges depends on whether dynamic relations are in use. The simplest scenario is if they are, in which case the edges are split into contiguous batches (each one having the size specified in the batch_size configuration key, except possibly the last one which could be smaller). Training is then performed on that batch before moving on to the next one.<br>worker训练边集合的方式取决于是否使用动态关系。最简单的情况是，如果边被分成连续的批次，（每个批次具有一样的大小，并且其在配置文件的batch_size中指定，最后一个批次可能会小些。）训练分批次依次进行训练。</p>
<p>When dynamic relations are not in use, however, the loss can only be computed on a set of edges that are all of the same type. Thus the worker first randomly samples a relation type, with probability proportional to the number of edges of that type that are left in the pool. It then takes the first batch_size relations of that type (or fewer, if not enough of them are left), removes them from the pool and performs training on them.<br>当不使用动态关系的时候，损失函数将只能用于同种关系类型的边计算。因此worker首先需要随机的选出某一种关系类型的样本，（挑选概率和池子残留的边成正比）。随后，其采用该类型的第一个batch_size（如果剩余的不多的话，数目可能会很少）,从池子中移除然后进行训练。</p>
]]></content>
      <tags>
        <tag>PyTorch-BigGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-BigGraph 数据模型</title>
    <url>/2020/10/22/PBG-Data-model/</url>
    <content><![CDATA[<h1 id="PBG模型"><a href="#PBG模型" class="headerlink" title="PBG模型"></a>PBG模型</h1><p>PBG operates on directed multi-relation multigraphs, whose vertices are called entities. Each edge connects a source to a destination entity, which are respectively called its left- and right-hand side (shortened to LHS and RHS). Multiple edges between the same pair of entities are allowed. Loops, i.e., edges whose left- and right- hand sides are the same, are allowed as well.<br>PBG作用在有向多关系多图上，其中，图的顶点称为实体。每一条边将源实体连接到目标实体，源实体称为左侧，目标实体称为右侧(缩写为LHS和RHS)同一对实体之间可以有多个边。循环也是允许的，例如，LHS和RHS是相同的边.(A-&gt;B B-&gt;A)</p>
<blockquote>
<p>key point: directed, multi-relation, multigraph </p>
</blockquote>
<p>Each entity is of a certain entity type (one and only one type per entity). Thus, the types partition all the entities into disjoint groups. Similarly, each edge also belongs to exactly one relation type. All edges of a given relation type must have all their left-hand side entities of the same entity type and, similarly, all their right-hand side entities of the same entity type (possibly a different entity type than the left-hand side one). This property means that each relation type has a left-hand side entity type and a right-hand side entity type.<br>每一个实体都具有某种实体类型(每个实体都只有一种类型)。因此，实体的类型将所有的实体划分成不相交的组。类似的，每一条边也只属于个唯一的关系类型。给定关系类型的边的LHS/RHS实体都只属于一个实体类型（左右两侧的实体类型可以不同）。此属性意味着每种关系类型都具有左侧实体类型和右侧实体类型。</p>
<blockquote>
<p>key point: entity, relation, entity type, relation type</p>
</blockquote>
<p><img src="/image/PBG_entity_relation.png"><br>In this graph, there are 14 entities: 5 of the red entity type, 6 of the yellow entity type and 3 of the blue entity type; there are also 12 edges: 6 of the orange relation type (between red and yellow entities), 3 of the purple entity type (between red and blue entities) and 3 of the green entity type (between yellow and blue entities).<br>在该图中，存在14个实体：红色实体类型的5个，黄色实体类型的6个和蓝色实体类型的3个； 还有12条边：橙色关联类型的6个（在红色和黄色实体之间），紫色关联类型的3个（在红色和蓝色实体之间）和绿色关联类型的3个（在黄色和蓝色实体之间）。</p>
<p>In order for PBG to operate on large-scale graphs, the graph is broken up into small pieces, on which training can happen in a distributed manner. This is first achieved by further splitting the entities of each type into a certain number of subsets, called partitions. Then, for each relation type, its edges are divided into buckets: for each pair of partitions (one from the left- and one from the right-hand side entity types for that relation type) a bucket is created, which contains the edges of that type whose left- and right-hand side entities are in those partitions.<br>为了使得PBG在大型图形上运行，图形将被分解成小块，可以在这些小块上进行分布式训练。首先通过将每种类型的实体进一步拆分为一定数量的子集（称为分区）来实现。 然后，对于每种关系类型，它的边被划分成桶：对于每一对分区（对于该关系类型，一个分区是来源于LHS的实体类型，一个分区是来源于RHS的实体类型），一个存储桶被创建，这个存储桶中包含了特定类型的边及对应左、右侧实体类型的实体。</p>
<blockquote>
<p>key point: partition, bucket </p>
</blockquote>
<p><img src="/image/PBG_partition_bucket.png"><br>This graph shows a possible partition of the entities, with red having 3 partitions, yellow having 3, and blue having only one (hence blue is unpartitioned). The edges displayed are those of the orange bucket between the partitions 2 of the red entities and the partition 1 of the yellow entities.<br>此图显示了实体的可能分区，其中红色具有3个分区，黄色具有3个分区，蓝色仅具有1个分区（因此，蓝色是未分区的）。 显示的边是红色实体的分区2和黄色实体的分区1之间的橙色桶的边。</p>
<blockquote>
<p>Note<br>For technical reasons, at the current state all entity types that appear on the left-hand side of some relation type must be divided into the same number of partitions (except unpartitioned entities). The same must hold for all entity types that appear on the right-hand side. In numpy-speak, it means that the number of partitions of all entities must be broadcastable to the same value.<br>出于技术原因，当前出现在某种关系类型左侧的所有实体类型必须划分为相同数量的分区（未分区的实体除外）。对于出现在右侧的所有实体类型，必须保持相同的状态。在numpy中，这意味着所有实体的分区数必须可以扩展到相同的值。<br>举个例子，比如说LHS以及RHS实体类型只有一种，然后关系类型也就是一种，这个时候对LHS划分成2个partition，那么RHS也要划分成2个partition，此时得到的桶个数为2x2=4个</p>
</blockquote>
<p>An entity is identified by its type, its partition and its index within the partition (indices must be contiguous, meaning that if there are 𝑁 entities in a type’s partition, their indices lie in the half-open interval [0,𝑁)). An edge is identified by its type, its bucket (i.e., the partitions of its left- and right-hand side entity types) and the indices of its left- and right-hand side entities in their respective partitions. An edge doesn’t have to specify its left- and right-hand side entity types, because they are implicit in the edge’s relation type.<br>实体由其类型，分区和分区内的索引标识(索引必须是连续的，这意味着如果类型的分区中有N个实体，则其索引位于[0，𝑁)中)。边由其类型，其存储桶（即其左侧和右侧实体类型的分区对）以及其左侧和右侧实体在它们各自分区中的索引来标识。边不必指定其左侧和右侧实体类型，因为它们隐含在边的关系类型中。</p>
<p>Formally, each bucket can be identifies by a pair of integers (𝑖,𝑗), where 𝑖 and 𝑗 are respectively the left- and right-hand side partitions. Inside that bucket, each edge can be identified by a triplet of integers (𝑥,𝑟,𝑦), with 𝑥 and 𝑦 representing respectively the left- and right-hand side entities and 𝑟 representing the relation type. This edge is “interpreted” by first looking up relation type 𝑟 in the configuration, and finding out that it can only have entities of type 𝑒1 on its left-hand side and of type 𝑒2 on its right-hand side. One can then determine the left-hand side entity, which is given by (𝑒1,𝑖,𝑥) (its type, its partition and its index within the partition), and, similarly, the right-hand side one which is (𝑒2,𝑗,𝑦).<br>形式上，每个桶都可以由一对整数（𝑖，𝑗）标识，其中𝑖和𝑗分别是左侧和右侧分区的索引。 在该桶内，每条边都可以由三元组（𝑥，𝑟，𝑦）标识，其中𝑥和𝑦分别表示左侧和右侧实体在各自分区中的索引，而𝑟表示关系类型。 边的解译通过:首先在配置文件中查找关系类型𝑟，然后发现𝑟的左侧只能是具有𝑒1类型的实体，而在右侧则是具有𝑒2类型的实体， 然后，可以确定左侧实体，该实体由（𝑒1，𝑖，𝑥）（𝑒1=实体类型，i=左侧分区索引，x=该实体在分区内的索引）给出，类似地，右侧实体为（𝑒2 ，𝑗，𝑦）。</p>
<p>源地址：<br><a href="https://torchbiggraph.readthedocs.io/en/latest/data_model.html">https://torchbiggraph.readthedocs.io/en/latest/data_model.html</a></p>
]]></content>
      <tags>
        <tag>PyTorch-BigGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-BigGraph I/O 格式</title>
    <url>/2020/10/27/PBG-I-O-format/</url>
    <content><![CDATA[<h1 id="PBG-I-O格式"><a href="#PBG-I-O格式" class="headerlink" title="PBG I/O格式"></a>PBG I/O格式</h1><h2 id="Entity-and-relation-types"><a href="#Entity-and-relation-types" class="headerlink" title="Entity and relation types"></a>Entity and relation types</h2><p>The list of entity types (each identified by a string), plus some information about each of them, is given in the <code>entities</code> dictionary in the configuration file. The list of relation types (each identified by its index in that list), plus some data like what their left- and right-hand side entity types are, is in the <code>relations</code> key of the configuration file.<br>实体类型的列表(每个实体类型由一个字符串标识)以及有关于他们的一些信息由配置文件中的实体字典提供。关系类型的列表（每个都由该列表中的索引标识）以及一些数据（如其左侧和右侧实体类型）在配置文件的relation key中指示。</p>
<h2 id="Entities"><a href="#Entities" class="headerlink" title="Entities"></a>Entities</h2><p>The only information that needs to be provided about entities is how many there are in each entity type’s partition. This is done by putting a file named <code>entity_count_type_part.txt</code> for each entity type identified by <code>type</code> and each partition <code>part</code> in the directory specified by the <code>entity_path</code> config parameter. These files must contain a single integer (as text), which is the number of entities in that partition. The directory where all these files reside must be specified as the <code>entity_path</code> key of the configuration file.<br>对于实体而言，其只需要提供每种实体类型的分区中有多少个实体这样一个信息即可。他通过将文件名称为<code>entity_count_type_part.txt</code>(<code>type</code>表示实体类型，<code>part</code>表示分区id)放到配置文件指定的文件夹来实现，这个文件夹在配置文件中的key为<code>entity_path</code>。 这些文件(entity_count_type1_part1.txt, entity_count_type2_part2.txt…)必须包含一个整数（作为文本），该整数表示在该分区中实体的数量。这些文件所在的目录名称必须指定为在配置文件下的<code>entity_path</code>。</p>
<p>It is possible to provide an initial value for the embeddings, by specifying a value for the <code>init_path</code> configuration key, which is the name of a directory that contains files in a format similar to the output format detailed in Checkpoint (possibly without the optimizer state dicts).<br>通过为<code>init_path</code>配置键指定一个值，可以为嵌入提供一个初始值。<code>init_path</code>值的目录下包含和Checkpoint类似的文件格式。（详情见checkpoint）</p>
<p>If no initial value is provided, it will be auto-generated, with each dimension sampled from the centered normal distribution whose standard deviation can be configured using the <code>init_scale</code> configuration key. For performance reasons the samples of all the entities of a certain type will not be independent.<br>如果为嵌入提供初始值，它将会自动生成，其每个维的值都是从正态分布中采样得到。可以通过配置文件中的init_scale来调整方差范围。出于性能原因，对于同一个类型下的所有实体的样本将不是独立的。</p>
<h2 id="Edges"><a href="#Edges" class="headerlink" title="Edges"></a>Edges</h2><p>For each bucket there must be a file that stores all the edges that fall in that bucket, of all relation types. This means that such a file is only identified by two integers, the partitions of its left- and right-hand side entities. It must be named <code>edges_lhs_rhs.h5</code> (where lhs and rhs are the above integers), it must be a HDF5 file containing three one-dimensional datasets of the same length, called rel, lhs and rhs. The elements in the 𝑖-th positions in each of them define the 𝑖-th edge: rel identifies the relation type (and thus the left- and right-hand side entity types), lhs and rhs given the indices of the left- and right-hand side entities within their respective partitions.<br>对于每一个桶，必须要有一个文件来存储该桶下的所有关系类型的所有边信息。这意味这样的一个文件仅由两个整数来进行标识，即它的左侧和右侧实体的分区id。 必须将其命名为edges_lhs_rhs.h5（其中lhs和rhs是左侧分区id和右侧分区id），它必须是HDF5文件，其中包含三个相同长度的一维数据集，分别称为rel，lhs和rhs。<br>在这三个一维数据集中，第𝑖个位置的元素定义了第i条边: rel定义了关系类型（并因此指定左侧和右侧实体类型），lhs和rhs定义了左右侧的实体在其各自分区下的索引。</p>
<p>To ease future updates to this format, each file must contain the format version in the format_version attribute of the top-level group. The current version is 1.<br>为了简化以后对该格式的更新，每个文件都必须在顶级组的format_version属性中包含格式版本。 当前版本是1。（这个是H5的格式问题）</p>
<p>If an entity type is unpartitioned (that is, all its entities belong to the same partition), then the edges incident to these entities must still be uniformly spread across all buckets.<br>如果某一个实体类型是未分区的（即，其所有实体都属于同一分区），则这些实体连接的的边必须仍然均匀地分布在所有存储桶中。</p>
<p>These files, for all buckets, must be stored in the same directory, which must be passed as the edge_paths configuration key. That key can actually contain a list of paths, each pointing to a directory of the format described above: in that case the graph will contain the union of all their edges.<br>对于所有桶对应的文件都必须存储在同一个目录下。该目录将会被配置到配置文件的<code>edge_paths</code>key下，该key实际上可以包含一个路径列表，每个路径都指向上述格式的目录：在这种情况下，图将包含其所有边的并集。</p>
<h2 id="Checkpoint"><a href="#Checkpoint" class="headerlink" title="Checkpoint"></a>Checkpoint</h2><p>The training’s checkpoints are also its output, and they are written to the directory given as the checkpoint_path parameter in the configuration. Checkpoints are identified by successive positive integers, starting from 1, and all the files belonging to a certain checkpoint have an extra component .vversion between their name and extension (e.g., something.v42.h5 for version 42).<br>训练的检查点也是其输出，它们被写入配置中指定为checkpoint_path参数的目录中。检查点由从1开始的连续正整数标识，并且属于某个检查点的所有文件的名称和扩展名之间都有一个额外的组件.vversion（例如，版本42的something.v42.h5）。</p>
<p>The latest complete checkpoint version is stored in an additional file in the same directory, called <code>checkpoint_version.txt</code>, which contains a single integer number, the current version.<br>最新的完整检查点版本存储在同一目录中的另一个文件中，该文件称为checkpoint_version.txt，其中包含一个整数，即当前版本。</p>
<p>Each checkpoint contains a JSON dump of the config that was used to produce it stored in the config.json file.<br>每一个检查点都为配置文件生成了对应json文件，并将其存储在config.json文件中。</p>
<p>After a new checkpoint version is saved, the previous one will automatically be deleted. In order to periodically preserve some of these versions, set the <code>checkpoint_preservation_interval</code> config flag to the desired period (expressed in number of epochs).<br>当一个新的检查点版本被保存时，上一个将会自动被删除。如果想要周期性的保存一些检查点，可以在配置文件中设置checkpoint_preservation_interval（以训练轮次数的形式）</p>
<h2 id="Model-parameters"><a href="#Model-parameters" class="headerlink" title="Model parameters"></a>Model parameters</h2><p>The model parameters are stored in a file named model.h5, which is a HDF5 file containing one dataset for each parameter, all of which are located within the model group. Currently, the parameters that are provided are:<br>• model/relations/idx/operator/side/param with the parameters of each relation’s operator.<br>• model/entities/type/global_embedding with the per-entity type global embedding.<br>模型参数存储在名为model.h5的文件中，该文件是一个HDF5文件，其中包含每个参数的一个数据集，所有数据集都位于模型组下。 当前，提供的参数有：<br>• model/relations/idx/operator/side/param -&gt; 对应每个算子的参数<br>• model/entities/type/global_embedding -&gt;带有每个实体类型全局嵌入</p>
<blockquote>
<p>🤔 这里好像和实际有点出入</p>
</blockquote>
<p>Each of these datasets also contains, in the state_dict_key attribute, the key it was stored inside the model state dict. An additional dataset may exist, optimizer/state_dict, which contains the binary blob (obtained through torch.save()) of the state dict of the model’s optimizer.</p>
<blockquote>
<p>🤔 H5格式</p>
</blockquote>
<p>Finally, the top-level group of the file contains a few attributes with additional metadata. This mainly includes the format version, a JSON-dump of the config and some information about the iteration that produced the checkpoint.<br>最后，文件的顶级组包含一些带有其他元数据的属性。 主要包括格式版本，配置的JSON转储以及有关生成检查点的迭代的一些信息。</p>
<h2 id="Embeddings"><a href="#Embeddings" class="headerlink" title="Embeddings"></a>Embeddings</h2><p>Then, for each entity type and each of its partitions, there is a file embeddings_type_part.h5 (where type is the type’s name and part is the 0-based index of the partition), which is a HDF5 file with two datasets. One two-dimensional dataset, called embeddings, contains the embeddings of the entities, with the first dimension being the number of entities and the second being the dimension of the embedding.<br>对于每种实体类型及其每个分区，都有一个embeddings_type_part.h5文件（其中type是类型的名称，part是分区的从0开始的索引），它是一个包含两个数据集的HDF5文件。 一个称为嵌入的二维数据集包含实体的嵌入，第一个维度是实体的数量，第二个维度是嵌入的维度。（其实就是实体嵌入的矩阵）（数据集1）</p>
<p>Just like for the model parameters file, the optimizer state dict and additional metadata is also included.<br>就像model.h5一样，embeedings.h5中还包含了一些关于优化状态等额外的元数据。（数据集2）</p>
]]></content>
      <tags>
        <tag>PyTorch-BigGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>PyTorch-BigGraph 概要</title>
    <url>/2020/10/22/PBG-overview/</url>
    <content><![CDATA[<h1 id="PBG概要"><a href="#PBG概要" class="headerlink" title="PBG概要"></a>PBG概要</h1><p>PyTorch-BigGraph (PBG) is a distributed system for learning graph embeddings for large graphs, particularly big web interaction graphs with up to billions of entities and trillions of edges.PBG now supports GPU training.<br>PyTorch-BigGraph（PBG）是一个用于学习学习大图（节点、关系众多），特别是那些具有多达数十亿个实体和数万亿条边的大型Web交互图嵌入的分布式系统。如今PBG也支持了GPU训练的过程。</p>
<blockquote>
<p>key point: PBG, distributed, big graph, embedding, GPU</p>
</blockquote>
<p>PBG was introduced in the PyTorch-BigGraph: A Large-scale Graph Embedding Framework paper, presented at the SysML conference in 2019.<br>PBG是于2019年发表在SysML会议上的一篇论文 PYTORCH-BIGGRAPH: A LARGE-SCALE GRAPH EMBEDDING SYSTEM被首次提出<br>论文地址: <a href="https://mlsys.org/Conferences/2019/doc/2019/71.pdf">https://mlsys.org/Conferences/2019/doc/2019/71.pdf</a></p>
<p>PBG trains on an input graph by ingesting its list of edges, each identified by its source and target entities and, possibly, a relation type. It outputs a feature vector (embedding) for each entity, trying to place adjacent entities close to each other in the vector space, while pushing unconnected entities apart. Therefore, entities that have a similar distribution of neighbors will end up being nearby.<br>PBG通过提取图的边列表来进行embedding训练，每条边由其源实体,目标实体以及一个可能的关系类型作为标识。PBG对每个实体输出一个特征向量（嵌入）。它通过将相邻的实体在向量空间中彼此靠近放置，不相邻的实体彼此远离放置。通过这样的手段，相似的实体最终的嵌入互相靠近。</p>
<blockquote>
<p>key point: 结点向量间的距离能够衡量原图中的邻接关系强弱。</p>
</blockquote>
<p>It is possible to configure each relation type to calculate this “proximity score” in a different way, with the parameters (if any) learned during training. This allows the same underlying entity embeddings to be shared among multiple relation types.<br>在训练过程中，可以通过配置每种关系类型来计算接近程度以及参数学习。如此一来一些相同的实体嵌入可以被多种关系类型进行共享。</p>
<p>The generality and extensibility of its model allows PBG to train a number of models from the knowledge graph embedding literature, including TransE, RESCAL, DistMult and ComplEx.<br>模型的通用性和可扩展性使得PBG可以从知识图嵌入文献中训练许多模型，包括TransE，RESCAL，DistMult和ComplEx。</p>
<blockquote>
<p>key point: embedding algorithm: TransE, RESCAL, DistMult, ComplEx</p>
</blockquote>
<p>PBG is designed with scale in mind, and achieves it through:<br>PBG的设计考虑了规模，并通过以下方法实现了规模：</p>
<p>1.graph partitioning, so that the model does not have to be fully loaded into memory<br>2.multi-threaded computation on each machine<br>3.distributed execution across multiple machines (optional), all simultaneously operating on disjoint parts of the graph<br>4.batched negative sampling, allowing for processing &gt;1 million edges/sec/machine with 100 negatives per edge</p>
<p>1.图形分区，因此模型不必完全加载到内存中<br>2.每台机器上的多线程计算<br>3.在多台计算机上分布执行（可选），所有这些操作同时在图的不连续部分上运行(数据分布)<br>4.批量负采样，可处理 &gt;1,000,00 个边/秒/机器, 每条边100个负采样</p>
<blockquote>
<p>key point: partition, distributed,  batched negative sampling</p>
</blockquote>
<p>PBG is not optimized for small graphs. If your graph has fewer than 100,000 nodes, consider using KBC with the ComplEx model and N3 regularizer. KBC produces state-of-the-art embeddings for graphs that can fit on a single GPU. Compared to KBC, PyTorch-BigGraph enables learning on very large graphs whose embeddings wouldn’t fit in a single GPU or a single machine, but may not produce high-quality embeddings for small graphs without careful tuning.<br>PBG并未针对小型图形进行优化。如果图少于100,000个节点，请考虑将KBC与ComplEx模型和N3正则化器一起使用。 KBC为可放在单个GPU上的图形生成最先进的嵌入。与KBC相比，PyTorch-BigGraph支持在非常大的图上进行学习，这些图的嵌入无法在单个GPU或单个机器中完成，但是PBG存在的缺点是其可能无法为小型图生成高质量的嵌入如果没有很好的调参的话。</p>
<p>源地址：<br><a href="https://github.com/facebookresearch/PyTorch-BigGraph">https://github.com/facebookresearch/PyTorch-BigGraph</a></p>
]]></content>
      <tags>
        <tag>PyTorch-BigGraph</tag>
      </tags>
  </entry>
  <entry>
    <title>PSL</title>
    <url>/2020/10/11/Probabilistic-Models-for-KG-Construction/</url>
    <content><![CDATA[<h1 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h1><p>在知识图谱中，主要需要解决的有三个问题:  (节点，属性，关系)</p>
<ol>
<li>Who are the entities (nodes) in the graph?</li>
<li>What are their attributes and types (labels)?</li>
<li>How are they related (edges)?<br><img src="/image/KG-problem.png"></li>
</ol>
<p>知识图谱的构建主要就是通过IE将互联网上各式各样的资源进行提取，整合得到结构化的数据(说起来容易，做起来难！)</p>
<p><img src="/image/build-KG.png"></p>
<p>提取到的知识可能存在的一些问题:</p>
<ol>
<li>ambiguous (一般我们说ambiguous 指的是多个名字指向一个entity， variant指的是一个entity有多个名字)<ul>
<li>Beetles, beetles, Beatles 这三个name可能都是指向一个实体甲壳虫，但是名字不同</li>
<li>citizenOf, livedIn, bornIn 这三个property可能都是指向一个实体，表达的意思为该实体住在某一个地方</li>
</ul>
</li>
<li>incomplete<ul>
<li>missing relationship; missing labels; missing entities</li>
</ul>
</li>
<li>inconsistent<ul>
<li>exclusive labels (alive, dead), 提取到的知识表明一个人既已经去世又还在人世</li>
<li>domain-range constraints，提取到一个relationship例如人的年龄为一朵花的名字(age属性一般为int)</li>
<li>一个人的配偶有多个存在(common sense: 一般认为配偶为一对)</li>
</ul>
</li>
</ol>
<p>例子: NELL在知识提取中存在的问题:<br>NELL: Never-Ending Language Learner CMU研究的一个人工智能语言学习程序,从Web文本中获取知识，并将其添加到内部知识库内 ,使用机器学习算法学习新入库的知识，巩固对知识的理解。<br>特点: Large-scale IE project; Lifelong learning: aims to “read the web”; Ontology of known labels and relations; Knowledge base contains millions of facts</p>
<p>存在问题:</p>
<ol>
<li>Entity co-reference errors, 例如对于Kyrgyzstan(吉尔吉斯斯坦,中亚的一个国家)这样一个实体，他具有许多的variants(Kyrgystan, Kyrgistan, Kyrghyzstan, Kyrgzstan, Kyrgyz Republic), NELL不能很好将这些variant完全映射到同一个实体上。</li>
<li>Missing and spurious labels, 例如Kyrgyzstan被标注为鸟或者国家</li>
<li>Missing and spurious relations, 例如Kyrgyzstan的位置，通过IE可能得到不同的地区归属。</li>
<li>Violations of ontological knowledge </li>
</ol>
<blockquote>
<p>由于知识提取过程中的诸多问题，想要很好的解决这些问题需要jointly considering multiple extractions.</p>
</blockquote>
<p>图谱构建方法:</p>
<ol>
<li>Clean and complete extraction graph</li>
<li>Incorporate ontological constraints and relational patterns</li>
<li>Discover statistical relationships within knowledge graph</li>
</ol>
<h1 id="PSL-Probabilistic-soft-logic-概率软逻辑"><a href="#PSL-Probabilistic-soft-logic-概率软逻辑" class="headerlink" title="PSL (Probabilistic soft logic) 概率软逻辑"></a>PSL (Probabilistic soft logic) 概率软逻辑</h1><blockquote>
<p>It’s not a black-and-white issue.</p>
</blockquote>
<h2 id="从一个例子说起-美国选民派别分类-Voter-Party-Classification"><a href="#从一个例子说起-美国选民派别分类-Voter-Party-Classification" class="headerlink" title="从一个例子说起, 美国选民派别分类 (Voter Party Classification)"></a>从一个例子说起, 美国选民派别分类 (Voter Party Classification)</h2><p><img src="/image/vote-classification.png"></p>
<p>各个角度的信息来分析一名美国选民的政治态度:</p>
<p><img src="/image/voter_attitude.png"></p>
<p>IDEA: <strong>Collective Classification</strong></p>
<p>假设分析A的政治态度，可以通过其配偶的政治态度，其tweet粉丝的观点，个人的行为来进行分析，通过制定一些规则来确定这个人是支持共和党还是民主党。<br><img src="/image/vote_opinion.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Collective Classification with PSL</span><br><span class="line">规则: 如果A -&gt; 那么B </span><br><span class="line"></span><br><span class="line">&#x2F;* Local rules *&#x2F;</span><br><span class="line">5.0: Donates(A, P) -&gt; Votes(A, P)</span><br><span class="line">0.3: Mentions(A, “Affordable Health”) -&gt; Votes(A, “Democrat”)</span><br><span class="line">0.3: Mentions(A, “Tax Cuts”) -&gt; Votes(A, “Republican”)</span><br><span class="line"></span><br><span class="line">&#x2F;* Relational rules *&#x2F;</span><br><span class="line">1.0: Votes(A,P) &amp; Spouse(B,A) -&gt; Votes(B,P)</span><br><span class="line">0.3: Votes(A,P) &amp; Friend(B,A) -&gt; Votes(B,P)</span><br><span class="line">0.1: Votes(A,P) &amp; Colleague(B,A) -&gt; Votes(B,P)</span><br><span class="line"></span><br><span class="line">&#x2F;* Range constraint *&#x2F;</span><br><span class="line">Votes(A, “Republican”) + Votes(A, “Democrat”) &#x3D; 1.0 .</span><br></pre></td></tr></table></figure>

<h2 id="为什么需要PSL"><a href="#为什么需要PSL" class="headerlink" title="为什么需要PSL"></a>为什么需要PSL</h2><p>通过上面的例子，可以发现，通过制定一些比较好的规则，可以为提取的信息进行一些比较高质量的标注。</p>
<p>存在问题: </p>
<ol>
<li><p>规则的制定依赖于提取到的信息，如果提取到的知识存在问题，那么一定是garbage in - garbage out.<br> 例子:<br> Lbl(Socrates, Man) &amp; Sub(Man, Mortal) -&gt; Lbl(Socrates, Mortal)<br> 假如提取到的知识没有正确的将Socrates标注为男性，那么永远也得不到Lbl(Socrates, Mortal)这样的知识。</p>
<p> 解决措施: probabilistic models  =&gt; P(new facts|extraction infos)<br> P(Lbl(Socrates, Mortal)|Lbl(Socrates,Man)=0.9)</p>
</li>
<li><p>多条规则之间可能产生冲突<br> 例子:<br> B的正确性无法确定:<br> A -&gt; B 符合<br> C -&gt; B 不符合<br> D -&gt; B 符合</p>
<p> 解决措施: Soft Logic<br> A -&gt; B 符合 0.7<br> C -&gt; B 不符合 0.2<br> D -&gt; B 符合 0.9</p>
</li>
</ol>
<h2 id="Soft-Probability"><a href="#Soft-Probability" class="headerlink" title="Soft Probability"></a>Soft Probability</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">P -&gt; Q</span><br><span class="line">&#x2F;* Soft Logic Penalty *&#x2F;</span><br><span class="line">if P &lt; Q</span><br><span class="line">	return satisfication</span><br><span class="line">else:</span><br><span class="line">	return P-Q</span><br><span class="line"></span><br><span class="line">Closed Form 封闭世界原则</span><br><span class="line">!Q &#x3D; 1-Q</span><br><span class="line">P -&gt; Q &#x3D; max(0, P-Q)</span><br><span class="line">P &amp;  Q &#x3D; max(0, P+Q-1)</span><br><span class="line">P |  Q &#x3D; min(1, P+Q)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="PSL-model"><a href="#PSL-model" class="headerlink" title="PSL model"></a>PSL model</h2><ul>
<li>PSL finds optimal assignment for all unknowns</li>
<li>Optimal = minimizes the soft-logic penalty</li>
<li>Fast, joint convex optimization using ADMM</li>
<li>Supports learning rule weights and latent variables</li>
</ul>
<h1 id="图谱模型的建立"><a href="#图谱模型的建立" class="headerlink" title="图谱模型的建立"></a>图谱模型的建立</h1><p>步骤:<br>Define joint probability distribution on knowledge graphs<br>Each candidate fact in the knowledge graph is a variable<br>Statistical signals, ontological knowledge and rules parameterize the dependencies between variables<br>Find most likely knowledge graph by optimization/sampling</p>
<h2 id="Knowledge-Graph-Identification-KGI"><a href="#Knowledge-Graph-Identification-KGI" class="headerlink" title="Knowledge Graph Identification (KGI)"></a>Knowledge Graph Identification (KGI)</h2><p>Knowledge Graph Identification (KGI): 解决图谱中存在的一系列问题的方案</p>
<ul>
<li>Performs graph identification:<ul>
<li>entity resolution</li>
<li>collective classification</li>
<li>link prediction</li>
</ul>
</li>
<li>Enforces ontological constraints</li>
<li>Incorporates multiple uncertain sources</li>
</ul>
<p>P(Who, What, How | Extractions)</p>
<h2 id="图谱中probability的获得"><a href="#图谱中probability的获得" class="headerlink" title="图谱中probability的获得"></a>图谱中probability的获得</h2><p>Statistical signals from text extractors and classifiers<br>    ex:<br>    P(R(John,Spouse,Yoko))=0.75; P(R(John,Spouse,Cynthia))=0.25<br>    LevenshteinSimilarity(Beatles, Beetles) = 0.9</p>
<p>Ontological knowledge about domain<br>    ex:<br>    Functional(Spouse) &amp; R(A,Spouse,B) -&gt; !R(A,Spouse,C)<br>    Range(Spouse, Person) &amp; R(A,Spouse,B) -&gt; Type(B, Person)</p>
<p>Rules and patterns mined from data<br>    ex:<br>    R(A, Spouse, B) &amp; R(A, Lives, L) -&gt; R(B, Lives, L)<br>    R(A, Spouse, B) &amp; R(A, Child, C) -&gt; R(B, Child, C)</p>
<h2 id="定义一个graphical-models"><a href="#定义一个graphical-models" class="headerlink" title="定义一个graphical models"></a>定义一个graphical models</h2><p>有许多种方式去定一个图模型，这里使用PSL(使用规则)<br>PSL infers a “truth value” for each fact via optimization</p>
<h3 id="Rules-for-KG-Model"><a href="#Rules-for-KG-Model" class="headerlink" title="Rules for KG Model"></a>Rules for KG Model</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">100: 	Subsumes(L1,L2)   &amp; Label(E,L1)      -&gt;  Label(E,L2)</span><br><span class="line">100:	Exclusive(L1,L2)  &amp; Label(E,L1)      -&gt; !Label(E,L2)</span><br><span class="line"></span><br><span class="line">100:	Inverse(R1,R2)    &amp; Relation(R1,E,O) -&gt;  Relation(R2,O,E)</span><br><span class="line">100:	Subsumes(R1,R2)   &amp; Relation(R1,E,O) -&gt;  Relation(R2,E,O)</span><br><span class="line">100:	Exclusive(R1,R2)  &amp; Relation(R1,E,O) -&gt; !Relation(R2,E,O)</span><br><span class="line"></span><br><span class="line">100:	Domain(R,L)       &amp; Relation(R,E,O)  -&gt;  Label(E,L)</span><br><span class="line">100:	Range(R,L)        &amp; Relation(R,E,O)  -&gt;  Label(O,L)</span><br><span class="line"></span><br><span class="line">10:	SameEntity(E1,E2) &amp; Label(E1,L)      -&gt;  Label(E2,L)</span><br><span class="line">10: 	SameEntity(E1,E2) &amp; Relation(R,E1,O) -&gt;  Relation(R,E2,O)</span><br><span class="line"></span><br><span class="line">1:	Label_OBIE(E,L)                      -&gt;  Label(E,L)</span><br><span class="line">1:	Label_OpenIE(E,L)                    -&gt;  Label(E,L)</span><br><span class="line">1:	Relation_Pattern(R,E,O)              -&gt;  Relation(R,E,O)</span><br><span class="line">1:	                                        !Relation(R,E,O)</span><br><span class="line">1:	                                        !Label(E,L)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Rules-to-Distributions"><a href="#Rules-to-Distributions" class="headerlink" title="Rules to Distributions"></a>Rules to Distributions</h3><p>Rules are grounded by substituting literals into formulas<br>Ground rules provide a joint probability distribution over knowledge graph facts, conditioned on the extractions</p>
]]></content>
      <tags>
        <tag>Knowledge Graph</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy学习</title>
    <url>/2020/09/22/Scrapy-learning/</url>
    <content><![CDATA[<h3 id="Scrapy-架构"><a href="#Scrapy-架构" class="headerlink" title="Scrapy 架构"></a>Scrapy 架构</h3><p><img src="/image/scrapy.png"></p>
<ol>
<li>The Engine gets the initial Requests to crawl from the Spider.(获取要爬的url)</li>
<li>The Engine schedules the Requests in the Scheduler and asks for the next Requests to crawl.（调度request到调度器中，形成一些列的url调度队列）</li>
<li>The Scheduler returns the next Requests to the Engine.（调度器调度完成，发送第一个request给引擎）</li>
<li>The Engine sends the Requests to the Downloader, passing through the Downloader Middlewares (see process_request()). （引擎发送第一个request给下载器）</li>
<li>Once the page finishes downloading the Downloader generates a Response (with that page) and sends it to the Engine, passing through the Downloader Middlewares (see process_response()).（下载器得到该request的response，返回给引擎）</li>
<li>The Engine receives the Response from the Downloader and sends it to the Spider for processing, passing through the Spider Middleware (see process_spider_input()).（引擎将response发给spider进行解析）</li>
<li>The Spider processes the Response and returns scraped items and new Requests (to follow) to the Engine, passing through the Spider Middleware (see process_spider_output()).（spider解析好需要的数据：包括：提取需要的内容+提取新的url请求，将处理好的数据发给引擎）</li>
<li>The Engine sends processed items to Item Pipelines, then send processed Requests to the Scheduler and asks for possible next Requests to crawl.（一方面引擎将得到的内容发给item，将得到的url请求发给调度器）</li>
<li>The process repeats (from step 1) until there are no more requests from the Scheduler.</li>
</ol>
<p>摘自:<a href="https://docs.scrapy.org/en/latest/topics/architecture.html">https://docs.scrapy.org/en/latest/topics/architecture.html</a></p>
<h3 id="Scrapy-使用"><a href="#Scrapy-使用" class="headerlink" title="Scrapy 使用"></a>Scrapy 使用</h3><h4 id="第一步-创建爬虫项目；"><a href="#第一步-创建爬虫项目；" class="headerlink" title="第一步: 创建爬虫项目；"></a>第一步: 创建爬虫项目；</h4><p>$scrapy startproject project_name</p>
<h4 id="第二步-设置settings"><a href="#第二步-设置settings" class="headerlink" title="第二步: 设置settings"></a>第二步: 设置settings</h4><p>settings关闭robots =》 POBOTSOXT_OBEY = True<br>…</p>
<h4 id="第三步-定义item信息"><a href="#第三步-定义item信息" class="headerlink" title="第三步: 定义item信息"></a>第三步: 定义item信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1Item</span>(<span class="params">scrapy.Item</span>):</span> <span class="comment"># ==&gt;&gt;&gt;修改item名称</span></span><br><span class="line">    <span class="comment"># define the fields for your item here like:</span></span><br><span class="line">    <span class="comment"># name = scrapy.Field()</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Items clearly define the common output data format in a separate file ,有的时候可能需要对传过来的数据进行进一步处理</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># example:</span></span><br><span class="line">    quote_content = Field(input_processor=MapCompose(remove_quotes),output_processor=TakeFirst())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_quotes</span>(<span class="params">text</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="第四步-编写代码逻辑"><a href="#第四步-编写代码逻辑" class="headerlink" title="第四步:编写代码逻辑"></a>第四步:编写代码逻辑</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">首先创建爬虫文件</span><br><span class="line">cd project_name</span><br><span class="line">scrapy genspider spider_name url</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse</span>(<span class="params">self, response</span>):</span></span><br><span class="line">	<span class="comment">## 编写代码逻辑</span></span><br><span class="line">	self.logger.info(<span class="string">&#x27;test...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">## 一般逻辑:</span></span><br><span class="line">    res = response.xpath(<span class="string">&quot;xxx&quot;</span>).getall() </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    	<span class="keyword">yield</span>&#123;</span><br><span class="line">    		<span class="comment"># 放入item中，更加复杂的写法见item itemloader</span></span><br><span class="line">    	&#125;</span><br><span class="line">     <span class="comment">##如果需要深度搜索，具有下一页之类的</span></span><br><span class="line">     next_page = response.xpath(xxx).get()</span><br><span class="line">    <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        next_page = response.urljoin(next_page)</span><br><span class="line">        <span class="keyword">yield</span> scrapy.Request(next_page, callback=self.parse)  <span class="comment"># 这里的callback 也可以重新写个函数进行回调 crapy.Request(next_page, callback=self.parse2)</span></span><br><span class="line">        <span class="comment"># 如果不进行url拼接的话，也可以直接</span></span><br><span class="line">        <span class="keyword">yield</span> response.follow(a, callback=self.parse)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse2</span>(<span class="params">self,response</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Ite/Itemloader</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">	loader = ItemLoader(item=Test1Item(), selector=i)</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	item = loader.load_item() <span class="comment"># 此时item便得到了提取的数据</span></span><br><span class="line">	<span class="keyword">yield</span> item</span><br></pre></td></tr></table></figure>

<h4 id="第五步-调试-输出"><a href="#第五步-调试-输出" class="headerlink" title="第五步:调试 输出"></a>第五步:调试 输出</h4><p>$ scrapy shell URL<br>response.xpath(xxx).getall()</p>
<p>$ scrapy crawl quotes -o xx.json</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title>社交网络</title>
    <url>/2020/10/23/Social-network/</url>
    <content><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>社交网络与图, 社交网络的聚类, 社区发现</p>
<h2 id="社交网络与图"><a href="#社交网络与图" class="headerlink" title="社交网络与图"></a>社交网络与图</h2><p>1.What is a network? a network can be defined as a graph in which nodes and/or edges have attributes (e.g. names). 带有属性信息的图</p>
<p>2.Network’s properties:</p>
<ul>
<li>size: # of nodes/edges</li>
<li>node degree: # of links to other nodes</li>
<li>degree distribution: probability that a randomly selected node has degree k<ul>
<li>scale-free network: network whose degree distribution follows a power law, at least asymptotically. 网络中的大部分节点只和很少节点连接，而有极少的节点与非常多的节点连接,幂律分布/长尾效应</li>
<li>Real networks are scale-free</li>
</ul>
</li>
<li>path,</li>
<li>shortest path </li>
<li>diameter: shortest path between most distant nodes/maximal shortest path<br>…</li>
</ul>
<p>3.Mathematical representation<br>Adjacency matrix : A<br>Path matrix: 可以通过邻接矩阵计算路径矩阵, A^l 结果表示为路径矩阵</p>
<p>3.Phenomena arise as a result of properties: </p>
<ul>
<li><p>Friendship paradox: on average, your friends have more friends than you do, 友谊悖论</p>
</li>
<li><p>Small world: most nodes are not neighbors of one another,but most nodes can be reached from every other by a small number of hops or steps. 小世界理论，六度空间</p>
<ul>
<li>The typical distance L between two randomly chosen nodes grows proportionally to the logarithm of the number of nodes N in the network, 两个节点的距离和整个网络的节点数的对数成正比<br><img src="/image/small_world.png"></li>
</ul>
</li>
<li><p>Perception bias in networks,网络中存在感知误差</p>
</li>
</ul>
<h2 id="社交网络的聚类"><a href="#社交网络的聚类" class="headerlink" title="社交网络的聚类"></a>社交网络的聚类</h2><p>方式:<br>1.Hierarchical</p>
<ul>
<li>Agglomerative (bottom-up):<br>  Initially, each point is a cluster，每个点都是一个cluster<br>  Repeatedly combine the two “nearest” clusters into one，不断往上去合并点，最终得到结果。<br>  Use distance metric</li>
<li>Divisive (top-down):  ==&gt;&gt; 本文关注的算法<br>  Start with one cluster and recursively split it 整个图为一个cluster，不断去细分clusters</li>
</ul>
<p>2.Point assignment<br>    Maintain a set of clusters<br>    Points belong to “nearest” cluster<br>    Use distance metric</p>
<p>社交网络中距离指标</p>
<p>1.d(x, y) is 0 if there is an edge and 1 if there is no such edge.<br>限制🚫: violate the triangle inequality<br>例子: 假设A,B,C三点,AC一边,那么 d(A,B) = d(B,C) = 0 and d(A,C) = 1 &gt; d(A,B) + d(B,C) </p>
<p>====&gt;</p>
<p>2.Shortest path distance: Minimum # of edges connecting to nodes:<br>例子: 假设A,B,C三点，边AB，BC，那么d(A,B) = d(B,C) = 1   and  d(A,C) = 2</p>
<p>The problem is more complex because the distance between data points (nodes) is not measured by Euclidian<br>由此可以看到传统的聚类方法（KNN，Kmeans）不太适用于社交网络的聚类，因为距离指标计算很复杂</p>
<p>====&gt;<br>3. Betweenness 中介性/居间性</p>
<p>Edge betweenness: # of shortest paths passing over the edge<br>边的中介性，简单理解就是经过该条边的最短路径数目</p>
<p>example:Betweenness of edge (a, b):<br>number of pairs of nodes x and y -&gt; x<br>edge (a,b) lies on the shortest path between x and y</p>
<p>However,if there are several shortest paths between x and y, edge (a,b) is credited with the fraction of those shortest paths that include edge (a,b)</p>
<p>但是!!!y-&gt;x的最短路径不只有一条，假设y-&gt;x的最短路径有3条，其中有一条进过了边(a,b),那么这一条最短路径为（a,b）的中介性贡献了1/3</p>
<p>A high score is bad: suggests that edge (a,b) runs between two different communities<br>我们可以发现如果一条边的中介性很高的话，表明a和b是属于两个不同的社区&lt;&lt;== 聚类实现</p>
<p><img src="/image/edge_betweeness.png"></p>
<h2 id="社区发现"><a href="#社区发现" class="headerlink" title="社区发现"></a>社区发现</h2><h3 id="利用betweeness的社区发现算法：Girvan-Newman-Algorithm"><a href="#利用betweeness的社区发现算法：Girvan-Newman-Algorithm" class="headerlink" title="利用betweeness的社区发现算法：Girvan-Newman Algorithm"></a>利用betweeness的社区发现算法：Girvan-Newman Algorithm</h3><p>Idea: discover communities using divisive hierarchical clustering (Start with one cluster (the social network) and recursively split it)</p>
<p>Strategy: edge betweenness(# of shortest paths passing through the edge)</p>
<p>Algorithm: Girvan-Newman Algorithm</p>
<p>Repeat until no edges are left:<br>    Calculate betweenness of edges<br>    Remove edges with highest betweenness</p>
<p>Result: Connected components are communities<br><img src="/image/GN.png"></p>
<p>但是通过上述的描述可以发现，通过不断的移除最大的edge betweeness，最后得到结果是一个个孤立的点，所以需要明确以下两点:<br>1.How to compute betweenness?<br>2.How to select the number of clusters?</p>
<h4 id="Compute-betweenness"><a href="#Compute-betweenness" class="headerlink" title="Compute betweenness"></a>Compute betweenness</h4><p>Strategy: BFS</p>
<p>1.Perform a breadth-first search (BFS) of the graph, starting at node X<br>首先对于每一个点 X，得到一个BFS tree，这个BFS tree可以反映出该点到其他所有点的最短路径</p>
<p>2.Label each node by the number of shortest paths that reach it from the root node<br>标记处每个点到root node X的最短路径数目<br><img src="/image/label_sp_num.png"></p>
<p>3.Calculate for each edge e, the sum over all nodes Y (of the fraction) of the shortest paths from the root X to Y that go through edge e<br>为每条边e计算从root nodeX到其他所有点Y的最短路径中经过e的总和(包括分数部分)</p>
<p>具体计算:<br><img src="/image/step1.png"><br>第一步: 从底部开始<br>• A and C are leaves: get credit = 1;<br>• Each of these nodes has only one parent, so their credit=1 is given to edges (B,A) and (B,C)<br>• At level 2, G is a leaf: gets credit = 1<br>• B gets credit 1 + credit of DAG edges entering from below = 1 + 1 +1 = 3<br>• B has only one parent, so edge (D,B) gets entire credit of node B = 3</p>
<p>第二步:碰见需要拆分的情况 G has 2 parents<br><img src="/image/step2.png"><br>• In this case, both D and F have just one shortest path from E to each of those nodes<br>    • So, give half credit of node G to each of those edges<br>    • Credit = 1/(1 + 1) = 0.5<br>• In general, how we distribute credit of a node to its edges depends on number of shortest paths<br>    • Say there were 5 shortest paths to D and only 3 to F<br>    • Then credit of edge (D,G) = 5/8 and credit of edge (F,G) = 3/8<br>• Node D gets credit = 1 + credits of edges below it = 1 + 3 + 0.5 = 4.5<br>• Node F gets credit = 1 + 0.5 = 1.5<br>• D has only one parent, so Edge (E,D) gets credit = 4.5 from D<br>• Likewise for F: Edge (E,F) gets credit = 1.5 from F.</p>
<p>To complete betweenness calculation, must: </p>
<ul>
<li>Repeat this for every node as root</li>
<li>Sum the contributions on each edge</li>
<li>Divide by 2 to get true betweenness<ul>
<li>since every shortest path will be counted twice, once for each of its endpoints</li>
</ul>
</li>
</ul>
<p>以上仅仅是对针对一个节点计算的各个边的betweeness，需要对每个节点重复这样的计算随后累加除以2得到最终结果。从这里也可以发现GN是针对无向图的，如果是有向图的话，就不需要除以2了。</p>
<h4 id="Select-the-number-of-clusters"><a href="#Select-the-number-of-clusters" class="headerlink" title="Select the number of clusters"></a>Select the number of clusters</h4><p>Communities: sets of tightly connected nodes</p>
<p>Modularity Q: A measure of how well a network is partitioned into communities<br>模块：衡量一个网络中社区聚类好坏的指标</p>
<blockquote>
<p>Modularity compares the number of edges inside a cluster with the expected number of edges that one would find in the cluster if the network were a random network with the same number of nodes and where each node keeps its degree, but edges are otherwise randomly attached.<br> Networks with high modularity have dense connections between the nodes within groups but sparse connections between nodes in different groups.<br> The null model is a graph which matches one specific graph in some of its structural features, but which is otherwise taken to be an instance of a random graph. The null model is used as a term of comparison, to verify whether the graph in question displays some feature, such as community structure, or not.</p>
</blockquote>
<p><img src="/image/modularity.png"></p>
<p>rclone mount GD: /nas/home/binzhang/data –allow-other –allow-non-empty –vfs-cache-mode writes</p>
<p>rclone mount GD: /nas/home/binzhang/GoogleDrive –allow-other –allow-non-empty –vfs-cache-mode writes</p>
<p> rclone copy /home/backup gdrive:backu</p>
]]></content>
      <tags>
        <tag>Data mining</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage systems</title>
    <url>/2020/09/08/Storage-systems/</url>
    <content><![CDATA[<h2 id="Storage-Device"><a href="#Storage-Device" class="headerlink" title="Storage Device"></a>Storage Device</h2><h3 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h3><p><img src="/image/storage_hierarchy.png"></p>
<h3 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h3><ul>
<li>Capacity(bytes) - How much data it can hold</li>
<li>Cost($) -  Price per byte of storage</li>
<li>Bandwidth(bytes/sec) - Number of bytes that can be transferred per second;  read and write bandwidth may be different</li>
<li>Latency(sec) - Time elapsed, waiting for response/delivery of data</li>
</ul>
<h3 id="Basic-Function-CRUD"><a href="#Basic-Function-CRUD" class="headerlink" title="Basic Function : CRUD"></a>Basic Function : CRUD</h3><ul>
<li>C(reate)/write</li>
<li>R(ead)</li>
<li>U(pdate)/overwrite</li>
<li>D(elete)</li>
</ul>
<h3 id="Some-terms"><a href="#Some-terms" class="headerlink" title="Some terms"></a>Some terms</h3><ul>
<li>Access times: Time taken before drive is ready to transfer data 一般来说，物理设备（硬盘，内存..）在进行数据的转换前需要索引到目标位置， 内存-纳秒 SSD-微秒 HDD-毫秒</li>
<li>Access pattern: how storage read/write data <ul>
<li>Sequential: Data to be accessed are located next to each other or sequentially on the device</li>
<li>Random: Access data located randomly on storage device</li>
</ul>
</li>
<li>Completion Time：Time to complete an read/write operation <ul>
<li><strong>CompletionTime = Latency + Size/Bandwidth</strong></li>
<li>Depends on lots of factors(device, operation type, access pattern…)</li>
</ul>
</li>
</ul>
<p>Note: 这里主要讨论HDD和SSD</p>
<h2 id="Hard-Disk-Drive"><a href="#Hard-Disk-Drive" class="headerlink" title="Hard Disk Drive"></a>Hard Disk Drive</h2><h3 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/hdd.png"></p>
<ul>
<li>One or more spinning magnetic platters, typically two surface per platter</li>
<li>Data stored in tracks</li>
<li>Disk arm positions over the radial positon - swings across tracks but don’t extend</li>
<li>Data is read/written by disk head as platter spins</li>
</ul>
<p>Hard disk head movement while copying files between two folders：<br><a href="https://www.youtube.com/watch?v=BlB49F6ExkQ">https://www.youtube.com/watch?v=BlB49F6ExkQ</a></p>
<h3 id="Physical-characteristics"><a href="#Physical-characteristics" class="headerlink" title="Physical characteristics"></a>Physical characteristics</h3><ul>
<li>3.5” (diameter, common in desktops), 2.5” (common in laptops)</li>
<li>Rotational Speed: 4800/5400/7200/10000 RPM (rotations per minute)</li>
<li>Between 5-7 platters</li>
<li>Current capacity up to 10TB</li>
</ul>
<h3 id="Data-Storage"><a href="#Data-Storage" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>1 platter  is divided into a number of tracks</li>
<li>1 tracker is divided into N fixed size sectors<ul>
<li>sector size: 4KB</li>
<li>Entire sector is written “atomically” -&gt; sector为最小的操作单元，所以不论读写都首先进行sector的寻址</li>
</ul>
</li>
</ul>
<h3 id="Address-Method-CHS-cylinder-head-sector"><a href="#Address-Method-CHS-cylinder-head-sector" class="headerlink" title="Address Method - CHS(cylinder-head-sector)"></a>Address Method - CHS(cylinder-head-sector)</h3><h4 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h4><p>CHS is an early way to address a sector. (LBA(Logical Block Addressing) is  more common now.) </p>
<p><img src="/image/CHS.png"></p>
<p>举个例子：<br>#cylinders: 256<br>#heads: 16 (i.e., 8 platters, 2 heads/platter)<br>#sectors/track: 64<br>sector size = 4KB<br>=&gt; capacity of the drive:  2^8 * 2^6 * 2^2* 2^10 * 2^4 = 2^30 = 1GB</p>
<h4 id="address-step"><a href="#address-step" class="headerlink" title="address step"></a>address step</h4><p><strong>According to CHS, data can be located before transferring, then data can be transferred</strong></p>
<ol>
<li>Wait for the disk haed on right track    - seek time <ol>
<li>On average seek time is about  1⁄3  max seek time</li>
<li><img src="/image/seek-time.png"></li>
</ol>
</li>
<li>wait for the right sector to rotate under the head. - rotational latency <ol>
<li>On average: about 1⁄2 of time of a full rotation</li>
<li>example:  Assume 10,000 RPM (rotations per minute) 60000 ms/ 10000 rotations  = 6ms / rotation</li>
</ol>
</li>
</ol>
<h3 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h3><blockquote>
<p>T = T_seek + T_rotation + T_transfer<br>T_seek : Time to get the disk head on right track<br>T_rotation :Time to wait for the right sector to rotate under the head<br>T_transfer: Time to actually transfer data</p>
</blockquote>
<h4 id="T-transfer"><a href="#T-transfer" class="headerlink" title="T_transfer"></a>T_transfer</h4><p>Assume that data will be transferred:  512KB, 128 MB/sec transmission bandwidth<br>Transfer time:  512KB/128MB * 1000ms = 4ms</p>
<h4 id="Actual-Bandwidth"><a href="#Actual-Bandwidth" class="headerlink" title="Actual Bandwidth"></a>Actual Bandwidth</h4><p>Actual Bandwidth = data / actual time ，所以一般情况下实际带宽会小</p>
<h4 id="数据传输中的block和sector区分"><a href="#数据传输中的block和sector区分" class="headerlink" title="数据传输中的block和sector区分"></a>数据传输中的block和sector区分</h4><ul>
<li>Sector is the  basic unit of hard disk dirve</li>
<li>Block is the basic unit of file system</li>
<li>Block has 1 or more sectors  （in this course, assuming one block = one sector）</li>
</ul>
<p>硬盘本身没有block的概念，block概念存在于文件系统的概念中，文件系统是一个块一个块的读取数据，如果是按照一个sector一个sector的来读数据，太慢了，所以才有了block这样一个逻辑块的概念。</p>
<h4 id="不同access-pattern对读写的影响"><a href="#不同access-pattern对读写的影响" class="headerlink" title="不同access pattern对读写的影响"></a>不同access pattern对读写的影响</h4><ul>
<li>Sequential operation:<ul>
<li>May assume all sectors involved are on the same track<br>– need to seek to the right track or rotate to the first sector （一次seektime）<br>– But no rotation/seeking needed afterwardSSD</li>
</ul>
</li>
<li>Random operation:  <ul>
<li>May assume all sectors are on different tracks and sectors （多次seektime）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example: 7ms avg seek,  10,000 RPM  50 MB/sec transfer rate 4KB/block</span><br><span class="line">Sequential access of 10 MB:</span><br><span class="line">– Completion time = 7ms + 60*1000/10000/2 ms + 10/50 *1000 ms = 210ms</span><br><span class="line">– Actual bandwidth = 10MB/210ms = 47.62 MB/s</span><br><span class="line"></span><br><span class="line">Random access of 10 MB </span><br><span class="line">– block numbers: 10*1000/4 = 2500  (assume 1 block = 1 sector)</span><br><span class="line">– Completion time = 2500 * (7 + 3 + 4/50) = 25.2s</span><br><span class="line">– Actual bandwidth = 10MB / 25.2s = 0.397 MB/s</span><br></pre></td></tr></table></figure>

<h2 id="Soild-State-Drive"><a href="#Soild-State-Drive" class="headerlink" title="Soild State Drive"></a>Soild State Drive</h2><h3 id="Organization-1"><a href="#Organization-1" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/ssd.png"></p>
<p>SSD contains a number of flash memory chips</p>
<p><img src="/image/chip.png"></p>
<p>chip -&gt; dies -&gt; planes -&gt; blocks -&gt; pages (rows) -&gt; cells</p>
<h3 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h3><ul>
<li>All electronic, made from flash memory</li>
<li>Limited lifetime, can only write a limited number of times.</li>
<li>More expensive, less capacity  - 3 times or more expensive</li>
<li>Significantly better latency: no seek or rotational delay</li>
<li>Much better performance on random (however, write has much higher latency than read )</li>
</ul>
<h3 id="Data-Storage-1"><a href="#Data-Storage-1" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>Cells are made of floating-gate transistors : By applying high positive/negative voltage to control gate, electrons can be attracted to or repelled from floating gate<ul>
<li>State = 1, if no electrons in the floating gate</li>
<li>State = 0, if there are electrons (negative charges)<br>– Electrons stuck there even when power is off<br>– So state is retained</li>
</ul>
</li>
<li>Data in SSD are represented by the ‘01010…’ formats, that is the state of the electrons</li>
</ul>
<p><img src="/image/floating-gate.png"></p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul>
<li>Electrons on the floating gate affect the threshold voltage for the floating gate transistor to conduct</li>
<li>Higher voltage needed when gate has electrons</li>
</ul>
<p><img src="/image/ssd_read.png"></p>
<p>Steps: </p>
<ol>
<li>Apply Vint (intermediate voltage) </li>
<li>If the current is detected, gate has no electrons=&gt; bit = 1</li>
<li>If no current, gate must have electrons =&gt; bit = 0</li>
</ol>
<p><u><strong>Page is the smallest unit that can be read</strong></u></p>
<h4 id="Write-and-Erase"><a href="#Write-and-Erase" class="headerlink" title="Write and Erase"></a>Write and Erase</h4><h4 id="Write-and-erase"><a href="#Write-and-erase" class="headerlink" title="Write and erase"></a>Write and erase</h4><ul>
<li>Write: 1 =&gt; 0 (get electron)<ul>
<li>Apply high positive voltage (&gt;&gt; voltage for read) to the control gate</li>
<li>Attract electrons from channel to floating gate (through quantum tunneling)</li>
<li>Page is the smallest unit for write</li>
</ul>
</li>
<li>Erase: 0 =&gt; 1 (make electrons empty)<ul>
<li>Need to apply much higher negative voltage to the control gate</li>
<li>Get rid of electrons from floating gate</li>
<li>May stress surrounding cells(dangerous to do on individual pages)</li>
<li>Block is the smallest unit for erase</li>
</ul>
</li>
</ul>
<h3 id="P-E-cycle"><a href="#P-E-cycle" class="headerlink" title="P/E cycle"></a>P/E cycle</h3><blockquote>
<p>P/E cycle: Data is written to cells (P) and then erased (E)<br>Every write &amp; erase damages oxide layer surrounding the floating-gate to some extent</p>
</blockquote>
<ul>
<li>Page is the smallest unit for read and write (write is also called program, 1-&gt;0)</li>
<li>Block is the smallest unit for erase (0-&gt;1) – i.e., make cells “empty” (i.e., no electrons)  (关于为什么使用block作为最小擦除单元：SSD的物理结构导致，擦除过程会作用到整个block施加高电压，将电子吸引出来)</li>
</ul>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐系统总览</title>
    <url>/2020/10/03/recommendation-system/</url>
    <content><![CDATA[<h1 id="效用矩阵-utility-matrix"><a href="#效用矩阵-utility-matrix" class="headerlink" title="效用矩阵 (utility matrix)"></a>效用矩阵 (utility matrix)</h1><p>一般的推荐系统中有两类元素，一类是user，一类是item(例如电影、音乐…)，可以用一个矩阵表示这些数据<br>每一行表示每一个user，每一列表示一个item, <code>M[i][j]</code>表示第i个用户对第j项的评分。</p>
<p>一般效用矩阵都是稀疏的，需要做的就是填充这些缺失值</p>
<ul>
<li>Gathering known ratings for matrix</li>
<li>Extrapolate unknown ratings from the known ones</li>
<li>Evaluating extrapolation methods</li>
</ul>
<h1 id="长尾效应-The-Long-tail"><a href="#长尾效应-The-Long-tail" class="headerlink" title="长尾效应 (The Long tail)"></a>长尾效应 (The Long tail)</h1><p>物理世界和在线世界的差别称为长尾现象，长尾现象要求互联网必须对每个用户进行推荐。</p>
<ul>
<li>实际的物理实体店中受限于空间，只能推荐畅销项目。</li>
<li>互联网推荐系统不受空间限制，可以推荐所有项目。</li>
</ul>
<p>关于在线世界与物理世界差异的例子:<br>What percentage of the top 10,000 titles in any online media store (Netflix, iTunes, Amazon, or any other) will rent or sell at least once a month?<br>Most people guess 20 percent.(80-20 rule, also known as Pareto’s principle (1896))<br>The right answer: 99 percent.(Demand for nearly every one of those top 10,000 titles.)</p>
<h1 id="推荐算法分类"><a href="#推荐算法分类" class="headerlink" title="推荐算法分类"></a>推荐算法分类</h1><h2 id="基于内容-Content-based"><a href="#基于内容-Content-based" class="headerlink" title="基于内容(Content based)"></a>基于内容(Content based)</h2><blockquote>
<p>思想:关注item的属性，计算各个item之间的相似度来进行推荐。 Recommend items to customer x that are similar to previous items rated highly by x.</p>
</blockquote>
<p><img src="/image/content-based.png"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>基于内容的推荐系统是建立在用户给出的数据之上的，用户给出的数据要么是对物品的直接评分或者是点击或者浏览物品，通过这些数据可以建立出基于这个用户的基本信息(user profile),后续对该用户物品推荐是基于其user profile，user profile越完善，推荐系统的效果越好。</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ul>
<li>Construct item profiles  (构建描述item的向量)<ul>
<li>特征可以是明确的属性值，也可以是从文档中提取出来的特征</li>
</ul>
</li>
<li>Construct user profiles （构建描述user喜好的向量）<ul>
<li>将user的偏好也表示成同一空间下的向量</li>
</ul>
</li>
<li>Recommend items to users based on content</li>
</ul>
<h3 id="优劣"><a href="#优劣" class="headerlink" title="优劣"></a>优劣</h3><p>优点：</p>
<ol>
<li>不需要其他user的数据</li>
<li>可以根据user的独特喜好来推荐item，也就是说可以推荐一些小众的item</li>
<li>推荐的原因可以很容易被解释<br>缺点：</li>
<li>内容的特征提取的问题，如何才能提取出最有用的特征（requires a lot of domain knowledge.）</li>
<li>只能推荐与用户历史数据中相似的item（model has limited ability to expand on the users’ existing interests）</li>
<li>无法利用其他用户的数据</li>
</ol>
<h2 id="协同过滤-Collaborative-filtering"><a href="#协同过滤-Collaborative-filtering" class="headerlink" title="协同过滤(Collaborative filtering)"></a>协同过滤(Collaborative filtering)</h2><blockquote>
<p>思想:关注item与user之间的关系，先识别相似用户，然后基于相似用户进行相似项目进行推荐。 Suggestions made to a user utilizing information across the entire user base</p>
</blockquote>
<p><img src="/image/CF.png"></p>
<h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>基于协同过滤的推荐系统是建立在许多用户的数据之上的，通过分析这些用户之间的相似度，发掘相似的用户,（假设用户A和B相似），推荐A一些B买过的东西。其主要精髓在于:物以类聚(item-based)，人以群分(user-based)。<br>It’s based on the idea that people who agree in their evaluations of certain items in the past are likely to agree again in the future.</p>
<p>关于一点思考：Users only see what they are expected to like.</p>
<h3 id="协同过滤的两类算法"><a href="#协同过滤的两类算法" class="headerlink" title="协同过滤的两类算法"></a>协同过滤的两类算法</h3><h4 id="Memory-based-approach"><a href="#Memory-based-approach" class="headerlink" title="Memory-based approach"></a>Memory-based approach</h4><p><img src="/image/CF-2.png"></p>
<h5 id="User-based-CF-k-nearest-neighbor-collaborative-filtering"><a href="#User-based-CF-k-nearest-neighbor-collaborative-filtering" class="headerlink" title="User-based CF (k-nearest neighbor collaborative filtering)"></a>User-based CF (k-nearest neighbor collaborative filtering)</h5><ul>
<li>思想: 为用户A找到相似用户，然后基于相似用户进行相似项目推荐</li>
<li>步骤:<ul>
<li>根据与A的相似度来为A的相似用户分配权重 </li>
<li>选择topk相似用户 </li>
<li>基于topk相似用户对于item的评分去预测A对item的评分 </li>
</ul>
</li>
<li>例子: 假设A有3个相似用户，B(sim=0.8, rating(h)=5),C(sim=0.3,rating(h)=4),D(sim=0.5,rating(h)=3) 预测A对于h的评分<ul>
<li>r_a(h) = 0.8x5+0.3x4+0.5x3 / (0.8+0.3+0.5) = 4.2</li>
</ul>
</li>
</ul>
<h5 id="Item-based-CF"><a href="#Item-based-CF" class="headerlink" title="Item-based CF"></a>Item-based CF</h5><ul>
<li>思想: 为物品x找相似物品，然后基于用户之前喜欢/买过的物品为其推荐最相似的物品</li>
<li>例子: 为电影进行评分时, similar items will be rated similarly by the same user</li>
</ul>
<h4 id="Model-based-approaches"><a href="#Model-based-approaches" class="headerlink" title="Model-based approaches"></a>Model-based approaches</h4><p><img src="/image/model-based-CF.png"></p>
<h5 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h5><p><img src="/image/MF.png"></p>
<h3 id="CF优劣"><a href="#CF优劣" class="headerlink" title="CF优劣"></a>CF优劣</h3><p>优点：</p>
<ol>
<li>利用了别的user的数据</li>
<li>不需要特征选择（不需要domain knowledge）</li>
</ol>
<p>缺点：</p>
<ol>
<li>需要足够的数据支持</li>
<li>稀疏，构建出的utility matrix稀疏且庞大</li>
<li>无法推荐从未被评级的item</li>
<li>不能根据某个用户的特有品位进行推荐</li>
</ol>
<h2 id="混合方法-Hybrid"><a href="#混合方法-Hybrid" class="headerlink" title="混合方法(Hybrid)"></a>混合方法(Hybrid)</h2>]]></content>
      <tags>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy 实例 - TripAdvisor信息抓取</title>
    <url>/2020/10/15/scrapy-example/</url>
    <content><![CDATA[<h1 id="TripAdvisor-Scrapy-实例"><a href="#TripAdvisor-Scrapy-实例" class="headerlink" title="TripAdvisor Scrapy 实例"></a>TripAdvisor Scrapy 实例</h1><h2 id="爬虫需求"><a href="#爬虫需求" class="headerlink" title="爬虫需求"></a>爬虫需求</h2><p>爬取洛杉矶地区的餐厅和酒店的相关信息</p>
<p>餐厅信息包括:</p>
<ul>
<li>餐厅名称</li>
<li>餐厅评星（几颗星）</li>
<li>餐厅排名（针对洛杉矶而言）</li>
<li>餐厅价格区间</li>
<li>餐厅菜品种类</li>
<li>餐厅地点</li>
<li>附近旅馆</li>
<li>附近餐厅</li>
<li>附近景点</li>
<li>用户评价</li>
</ul>
<p>酒店信息包括：</p>
<ul>
<li>酒店名称</li>
<li>酒店价格区间</li>
<li>酒店房间数</li>
<li>酒店评星</li>
<li>酒店设施</li>
<li>酒店特色</li>
<li>酒店星级</li>
<li>酒店房间类型</li>
<li>酒店风格</li>
<li>酒店地点</li>
<li>附近餐厅</li>
<li>附近景点</li>
<li>用户评价</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>Scrapy + MongoDB<br>代码: xxxx</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol>
<li>使用scrapd + spiderkeeper 进行可视化部署</li>
<li>log文件保存(settings.py中设置LOG_FILE  = “debug.log”)</li>
<li>使用 scrapy shell 进行xpath语法规则的调试以确保得到想要的结果</li>
</ol>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>10522 条餐厅数据 (50M)<br>1000 条酒店数据  (100M)</p>
]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Web Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title>spaCy学习</title>
    <url>/2020/09/10/spacy-learning/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>spaCy (/speɪˈsiː/) is an open-source software library for advanced natural language processing written in the programming languages Python and Cython.</p>
</blockquote>
<p>学习资源: <a href="https://spacy.io/">https://spacy.io/</a>  <a href="https://course.spacy.io/en">https://course.spacy.io/en</a></p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul>
<li>nlp   : contains the processing pipeline; includes language-specific rules for tokenization etc.</li>
<li>doc   : access information about the text in a structured way, and no information is lost.</li>
<li>token : tokens in a document – for example, a word or a punctuation character.</li>
<li>span  : a slice of the document consisting of one or more tokens</li>
<li>lexical attributes : <code>token.i</code>, <code>token.text</code>, <code>token.is_alpha</code>, <code>token.is_punct</code>, <code>token.like_num</code>… They refer to the entry in the vocabulary and don’t depend on the token’s context.</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入对应语言类 Note: Some language tokenizers require external dependencies. </span></span><br><span class="line"><span class="keyword">from</span> spacy.lang.zh <span class="keyword">import</span> Chinese   <span class="comment"># https://spacy.io/usage/models 查看lang后面对应的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建nlp实例</span></span><br><span class="line">nlp = Chinese() 	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用nlp对象处理一段文本并生成doc实例		</span></span><br><span class="line"><span class="comment"># When you call nlp on a string, spaCy first tokenizes the text and creates a document object.	  </span></span><br><span class="line">doc = nlp(<span class="string">&quot;这是一个句子。&quot;</span>) <span class="comment"># 底层调用 __call__方法					</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:  <span class="comment"># 遍历doc实例中的token							</span></span><br><span class="line">    print(token.text)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">一个</span></span><br><span class="line"><span class="string">句子</span></span><br><span class="line"><span class="string">。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用索引获得某一个token</span></span><br><span class="line">specific_token = doc[<span class="number">1</span>]	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用切片获得doc片段					</span></span><br><span class="line">span = doc[<span class="number">1</span>:<span class="number">3</span>]								</span><br><span class="line"></span><br><span class="line"><span class="comment"># token的一些属性</span></span><br><span class="line">doc = nlp(<span class="string">&quot;我花了20¥买了一个汉堡包。&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;Index:   &quot;</span>, [token.i <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;Text:    &quot;</span>, [token.text <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;is_alpha:&quot;</span>, [token.is_alpha <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;is_punct:&quot;</span>, [token.is_punct <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line">print(<span class="string">&quot;like_num:&quot;</span>, [token.like_num <span class="keyword">for</span> token <span class="keyword">in</span> doc])</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Index:    [0, 1, 2, 3, 4, 5, 6, 7, 8]</span></span><br><span class="line"><span class="string">Text:     [&#x27;我花&#x27;, &#x27;了&#x27;, &#x27;20&#x27;, &#x27;¥&#x27;, &#x27;买&#x27;, &#x27;了&#x27;, &#x27;一个&#x27;, &#x27;汉堡包&#x27;, &#x27;。&#x27;]</span></span><br><span class="line"><span class="string">is_alpha: [True, True, False, False, True, True, True, True, False]</span></span><br><span class="line"><span class="string">is_punct: [False, False, False, False, False, False, False, False, True]</span></span><br><span class="line"><span class="string">like_num: [False, False, True, False, False, False, False, False, False]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="统计模型"><a href="#统计模型" class="headerlink" title="统计模型"></a>统计模型</h3><p>来源: Models are trained on large datasets of labeled example texts.<br>作用: 词性标注 (Part-of-speech tags), 依存关系解析 (Syntactic dependencies), 命名实体识别 (Named entities)<br>优化: Can be updated with more examples to fine-tune predictions</p>
<h3 id="模型包"><a href="#模型包" class="headerlink" title="模型包"></a>模型包</h3><p>spaCy提供了很多预训练好的模型包，可以使用<code>spacy download</code>进行下载 <a href="https://spacy.io/usage/models">https://spacy.io/usage/models</a></p>
<p>The package provides </p>
<ul>
<li>binary weights that enable spaCy to make predictions;</li>
<li>vocabulary, and meta information to tell spaCy which language class to use;</li>
<li>how to configure the processing pipeline;</li>
</ul>
<p>导入模型包和通过初始化语言类的nlp实例区别？</p>
<ul>
<li>spacy.lang.xxx中包含其实是特定语言的代码和规则，包括停用词，数字之类,简单认为就是最基础的一些规则</li>
<li>模型包是建立在已经对大量的标记数据进行训练后得到的统计模型，简单认为是基于spacy.lang.xxx中某一种语言最基础规则之上,对大量数据进行训练学习得到的更多规则</li>
</ul>
<h3 id="词性标注-Part-of-speech-tags"><a href="#词性标注-Part-of-speech-tags" class="headerlink" title="词性标注 (Part-of-speech tags)"></a>词性标注 (Part-of-speech tags)</h3><p>通过标注每一个token的词性，为后于文本处理提供基础保证，<code>.pos_</code>属性返回词性标注的结果</p>
<h3 id="依存关系解析-Syntactic-dependencies"><a href="#依存关系解析-Syntactic-dependencies" class="headerlink" title="依存关系解析 (Syntactic dependencies)"></a>依存关系解析 (Syntactic dependencies)</h3><p>由于已经对于token做了词性标注，由此可以进一步来进行词与词之间的关系的预测。比如一个词是某一个句子或者物体的主语。<code>.dep_</code>属性返回预测的依存关系标注,<code>.head</code>属性返回当前token的parent token(也就是依存的那一个token)</p>
<p>关于依存关系:<br>20世纪70年代，Robinson提出依存语法中关于依存关系的四条公理：</p>
<ul>
<li>一个句子中只有一个成分是独立的；</li>
<li>其它成分直接依存于某一成分；</li>
<li>任何一个成分都不能依存与两个或两个以上的成分；</li>
<li>如果A成分直接依存于B成分，而C成分在句中位于A和B之间，那么C或者直接依存于B，或者直接依存于A和B之间的某一成分；</li>
</ul>
<p>依存结构是加标签的有向图，箭头从中心词指向从属，具体来说，箭头是从head指向child,举个例子： I love you,中 I 依存于 love,所以会有一条有向边从love指向I<br><img src="/image/dependency_scapy.png"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可视化依存关系图</span></span><br><span class="line"><span class="keyword">from</span> spacy <span class="keyword">import</span> displacy</span><br><span class="line">options = &#123;<span class="string">&quot;distance&quot;</span>: <span class="number">120</span>&#125;</span><br><span class="line">displacy.render(doc, style=<span class="string">&quot;dep&quot;</span>, options=options)</span><br></pre></td></tr></table></figure>

<p>常用的依存标签：<br>root:  中心词,一般为动词<br>nsubj: nominal subject,名词性主语<br>dobj:  direct object, 直接宾语<br>prep: 介词<br>pobj: 介词宾语<br>cc: 连词<br>compound: 复合词<br>advmod: 状语<br>det: 限定词<br>amod: 形容词修饰语</p>
<h3 id="命名实体识别-Named-entities"><a href="#命名实体识别-Named-entities" class="headerlink" title="命名实体识别 (Named entities)"></a>命名实体识别 (Named entities)</h3><p><code>doc.ents</code>读取模型预测出的所有命名实体,例如Bill Gates,使用<code>.label_</code>属性打印出实体标签，例如Person</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ python -m spacy download zh_core_web_sm </span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_md&quot;</span>)  <span class="comment"># load a model package by name and returns an nlp object.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;I love you!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the tokens</span></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    <span class="comment"># Print the text and the predicted part-of-speech tag</span></span><br><span class="line">    print(token.text, token.pos_)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I PRON</span></span><br><span class="line"><span class="string">love VERB</span></span><br><span class="line"><span class="string">you PRON</span></span><br><span class="line"><span class="string">! PUNCT</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.pos_, token.dep_, token.head.text)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">I PRON nsubj love</span></span><br><span class="line"><span class="string">love VERB ROOT love</span></span><br><span class="line"><span class="string">you PRON dobj love</span></span><br><span class="line"><span class="string">! PUNCT punct love</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Apple is looking at buying U.K. startup for $1 billion&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the predicted entities</span></span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    <span class="comment"># Print the entity text and its label</span></span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process a text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Microsoft Corporation is an American multinational technology company with headquarters in Redmond, Washington.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the predicted entities</span></span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    <span class="comment"># Print the entity text and its label</span></span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Microsoft Corporation ORG</span></span><br><span class="line"><span class="string">American NORP</span></span><br><span class="line"><span class="string">Redmond GPE</span></span><br><span class="line"><span class="string">Washington GPE</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get quick definitions of the most common tags and labels.</span></span><br><span class="line">spacy.explain(<span class="string">&#x27;NORP&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;Nationalities or religious or political groups&#x27;</span></span><br></pre></td></tr></table></figure>


<h3 id="基于规则的匹配抽取"><a href="#基于规则的匹配抽取" class="headerlink" title="基于规则的匹配抽取"></a>基于规则的匹配抽取</h3><p>使用预训练模型的缺陷：模型的预测是否正确取决于训练数据和处理的文本，如果处理的文本中许多规则没有被模型包含，则预测的精度不会很高。<br>解决方案: 使用预训练的模型 + 添加相应的规则</p>
<p>Match patterns</p>
<ul>
<li>Lists of dictionaries, one per token  [{},{},{}]</li>
<li>Match exact token texts</li>
<li>Match lexical attributes</li>
<li>Match any token attributes </li>
</ul>
<p>Match step:</p>
<ol>
<li>Import the <code>Matcher</code> from <code>spacy.matcher</code>.</li>
<li>Initialize it with the <code>nlp</code> object’s shared <code>vocab</code>.</li>
<li>Create patterns</li>
<li>Use the <code>matcher.add</code> to add the pattern to the matcher.</li>
<li>Call the matcher on the <code>doc</code> and store the result in the variable matches.</li>
<li>Iterate over the matches and get the matched span from the <code>start</code> to the <code>end</code> index.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line"><span class="keyword">from</span> spacy.matcher <span class="keyword">import</span> Matcher <span class="comment"># # Import the Matcher</span></span><br><span class="line"></span><br><span class="line">nlp = spacy.load(<span class="string">&quot;en_core_web_md&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Initialize the matcher with the shared vocab</span></span><br><span class="line">matcher = Matcher(nlp.vocab)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the pattern to the matcher</span></span><br><span class="line">pattern = [&#123;<span class="string">&quot;TEXT&quot;</span>: <span class="string">&quot;iPhone&quot;</span>&#125;, &#123;<span class="string">&quot;TEXT&quot;</span>: <span class="string">&quot;X&quot;</span>&#125;]</span><br><span class="line">matcher.add(<span class="string">&quot;IPHONE_PATTERN&quot;</span>, <span class="literal">None</span>, pattern)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实一个pattern就是一个或者多个token的组合，然后&#123;&#125;表示这个token需要满足的条件</span></span><br><span class="line"><span class="comment">#例子：</span></span><br><span class="line">pattern_example = [</span><br><span class="line">    &#123;<span class="string">&quot;LEMMA&quot;</span>: <span class="string">&quot;like&quot;</span>, <span class="string">&quot;POS&quot;</span>: <span class="string">&quot;VERB&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;POS&quot;</span>: <span class="string">&quot;NOUN&quot;</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Process some text</span></span><br><span class="line">doc = nlp(<span class="string">&quot;Upcoming iPhone X release date leaked&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Call the matcher on the doc</span></span><br><span class="line">matches = matcher(doc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterate over the matches</span></span><br><span class="line"><span class="keyword">for</span> match_id, start, end <span class="keyword">in</span> matches:</span><br><span class="line">    <span class="comment"># Get the matched span</span></span><br><span class="line">    matched_span = doc[start:end]</span><br><span class="line">    print(matched_span.text)</span><br><span class="line">    print(nlp.vocab.strings[match_id])  <span class="comment"># 通过match_id 获取当初加入pattern的名称)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;iPhone X&#x27;</span></span><br><span class="line"><span class="string">&#x27;IPHONE_PATTERN&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;!&quot;&#125;	Negation: match 0 times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;?&quot;&#125;	Optional: match 0 or 1 times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;+&quot;&#125;	Match 1 or more times</span></span><br><span class="line"><span class="string">&#123;&quot;OP&quot;: &quot;*&quot;&#125;	Match 0 or more times</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="Vocab-共享词汇表"><a href="#Vocab-共享词汇表" class="headerlink" title="Vocab:共享词汇表"></a>Vocab:共享词汇表</h3><ul>
<li>spaCy把所有共享数据都存在一个词汇表Vocab中</li>
<li>所有的字符串都被编码成哈希ID</li>
<li>Vocab库为一个双向的查询表，字符串-&gt;hash值； hash值-&gt;字符串</li>
<li>哈希不能逆求解,通过hash值检索某一个不在Vocab中的字符串会报错</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">&quot;I love you&quot;</span>)</span><br><span class="line">print(<span class="string">&quot;hash value:&quot;</span>, nlp.vocab.strings[<span class="string">&quot;love&quot;</span>])</span><br><span class="line">print(<span class="string">&quot;string value:&quot;</span>, nlp.vocab.strings[<span class="number">3702023516439754181</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">#一个Doc实例也可以暴露出它的词汇表和字符串</span></span><br><span class="line"><span class="comment">#另一种方式</span></span><br><span class="line">print(<span class="string">&quot;string value:&quot;</span>, doc.vocab.strings[<span class="number">3702023516439754181</span>])</span><br></pre></td></tr></table></figure>

<h3 id="Lexeme-语素"><a href="#Lexeme-语素" class="headerlink" title="Lexeme:语素"></a>Lexeme:语素</h3><p>Lexeme（语素）是词汇表中和语境无关的元素,代表着一个词的和语境无关的信息，比如文本本身，或者是这个词是否包含了英文字母,Lexeme中没有词性标注、依存关系或者实体标签这些和语境关联的信息。<br>在词汇表中查询一个字符串或者一个哈希ID就会获得一个lexeme。<code>lexeme.text</code>表示其文本, <code>lexeme.orth</code>表示其hash值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = nlp(<span class="string">&quot;I love you&quot;</span>)</span><br><span class="line">lexeme = nlp.vocab[<span class="string">&#x27;love&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印词汇的属性</span></span><br><span class="line">print(lexeme.text, lexeme.orth, lexeme.is_alpha)</span><br></pre></td></tr></table></figure>

<p>一句话总结就是：doc中的每一个token对应一个lexeme,其中保存着对应的文本信息和hash值,要拿到文本信息，首先去Vocab中查找对应的hash值。</p>
<h3 id="Doc-Span的手动创建"><a href="#Doc-Span的手动创建" class="headerlink" title="Doc, Span的手动创建"></a>Doc, Span的手动创建</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.tokens <span class="keyword">import</span> Doc,Span</span><br><span class="line">words = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>]</span><br><span class="line">spaces = [<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]</span><br><span class="line">doc = Doc(nlp.vocab, words=words, spaces=spaces) </span><br><span class="line"><span class="comment"># 三个参数：共享的词汇表，词汇和空格</span></span><br><span class="line"></span><br><span class="line">span = Span(doc, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 创建一个带标签的span  这里的带标签很有用！</span></span><br><span class="line">span_with_label = Span(doc, <span class="number">0</span>, <span class="number">2</span>, label=<span class="string">&quot;GREETING&quot;</span>)</span><br><span class="line"><span class="comment"># 把span加入到doc.ents中  doc.ents是可写的,可以人为添加</span></span><br><span class="line">doc.ents = [span_with_label]</span><br></pre></td></tr></table></figure>

<h3 id="语义相似度"><a href="#语义相似度" class="headerlink" title="语义相似度"></a>语义相似度</h3><p><code>Doc.similarity()</code>、<code>Span.similarity()</code>和<code>Token.similarity()</code></p>
<p>相似度的计算方式:</p>
<ul>
<li>通过词向量计算的，词向量是一个词汇的多维度的语义表示</li>
<li>词向量是用诸如Word2Vec算法在大规模语料上面生成的</li>
<li>spaCy默认返回两个向量的余弦相似度</li>
<li>Doc和Span的向量默认是由其token的平均值得到的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看词向量</span></span><br><span class="line">doc = nlp(<span class="string">&quot;I have a banana&quot;</span>)</span><br><span class="line"><span class="comment"># 通过token.vector属性获取向量</span></span><br><span class="line">print(doc[<span class="number">3</span>].vector)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 文档和文档相似度</span></span><br><span class="line">doc1 = nlp(<span class="string">&quot;I like fast food&quot;</span>)</span><br><span class="line">doc2 = nlp(<span class="string">&quot;I like pizza&quot;</span>)</span><br><span class="line">print(doc1.similarity(doc2))</span><br><span class="line"></span><br><span class="line"><span class="comment">## token和token相似度</span></span><br><span class="line">doc = nlp(<span class="string">&quot;I like pizza and pasta&quot;</span>)</span><br><span class="line">token1 = doc[<span class="number">2</span>]</span><br><span class="line">token2 = doc[<span class="number">4</span>]</span><br><span class="line">print(token1.similarity(token2))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 文档和token相似度</span></span><br><span class="line">doc = nlp(<span class="string">&quot;I like pizza&quot;</span>)</span><br><span class="line">token = nlp(<span class="string">&quot;soap&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">print(doc.similarity(token))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 文档和span相似度</span></span><br><span class="line">span = nlp(<span class="string">&quot;I like pizza and pasta&quot;</span>)[<span class="number">2</span>:<span class="number">5</span>] <span class="comment"># span.text = pizza and pasta</span></span><br><span class="line">doc = nlp(<span class="string">&quot;McDonalds sells burgers&quot;</span>)</span><br><span class="line">print(span.similarity(doc))</span><br></pre></td></tr></table></figure>

<h3 id="模型-规则"><a href="#模型-规则" class="headerlink" title="模型 + 规则"></a>模型 + 规则</h3><blockquote>
<p>将统计模型与规则系统结合使用，是自然语言处理工具箱里面最强大的方法之一</p>
</blockquote>
<p>模型: 根据训练语料库得到一系列规则的集合,spaCy功能一般包括:实体识别器、依存句法识别器、词性标注器<br>规则: 人为制定的模式匹配，适用于例子较少的情况, spaCy功能一般包括:分词器, Matcher, PhraseMatcher</p>
<p>PhraseMatcher:传进一个Doc实例而不是字典列表作为模板</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.matcher <span class="keyword">import</span> PhraseMatcher</span><br><span class="line"></span><br><span class="line">matcher = PhraseMatcher(nlp.vocab)</span><br><span class="line"></span><br><span class="line">pattern = nlp(<span class="string">&quot;Golden Retriever&quot;</span>)  <span class="comment"># 和Matcher不同的地方</span></span><br><span class="line">matcher.add(<span class="string">&quot;DOG&quot;</span>, <span class="literal">None</span>, pattern)</span><br><span class="line">doc = nlp(<span class="string">&quot;I have a Golden Retriever&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历匹配结果</span></span><br><span class="line"><span class="keyword">for</span> match_id, start, end <span class="keyword">in</span> matcher(doc):</span><br><span class="line">    <span class="comment"># 获取匹配到的span</span></span><br><span class="line">    span = doc[start:end]</span><br><span class="line">    print(<span class="string">&quot;Matched span:&quot;</span>, span.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个pattern如何进行add</span></span><br><span class="line"><span class="comment"># 下面的代码比这样的表达方式更快： [nlp(country) for country in COUNTRIES]</span></span><br><span class="line">patterns = list(nlp.pipe(COUNTRIES))</span><br><span class="line">matcher.add(<span class="string">&quot;COUNTRY&quot;</span>, <span class="literal">None</span>, *patterns)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 例子： 找符合pattern的一个span 并且获取这个span中的root，随后找到这个root的head</span></span><br><span class="line">span_root = span.root</span><br><span class="line">span_root_head = span.root.head</span><br><span class="line"><span class="comment"># 打印这个span的根头词符的文本及span的文本</span></span><br><span class="line">print(span_root_head.text, <span class="string">&quot;--&gt;&quot;</span>, span.text)</span><br></pre></td></tr></table></figure>

<h2 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h2><p><img src="/image/nlp_process.png"></p>
<p>词性标注: token.tag, token.pos<br>依存关系: token.dep, token.head<br>命名实体: 将检测到的实体添加到doc.ents<br>文本分类器: 适用于整个文本的类别，将其加入doc.cats</p>
<p>所有预训练的模型都包含了一些文件和一个meta.json。这个元数据定义了语种和流程等等，告诉spaCy应该去初始化那些组件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(nlp.pipe_names)  <span class="comment"># 流程组件名的列表</span></span><br><span class="line">print(nlp.pipeline)    <span class="comment"># (name, component)元组的列表</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[(&#x27;tagger&#x27;, &lt;spacy.pipeline.Tagger&gt;),</span></span><br><span class="line"><span class="string"> (&#x27;parser&#x27;, &lt;spacy.pipeline.DependencyParser&gt;),</span></span><br><span class="line"><span class="string"> (&#x27;ner&#x27;, &lt;spacy.pipeline.EntityRecognizer&gt;)]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="定制化流程组件"><a href="#定制化流程组件" class="headerlink" title="定制化流程组件"></a>定制化流程组件</h2><p>当一个文本已经被分词且Doc实例被创建后，流程组件会依次被调用。 spaCy支持一系列的原生组件，但是也可以在其中加入自己设计的组件，通过自己定制可以给doc和token添加一些属性。</p>
<blockquote>
<p>一个流程组件就是一个函数或者callable，它读取一个doc，修改和返回这个doc，作为下一个流程组件的输入。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_component</span>(<span class="params">doc</span>):</span></span><br><span class="line">    <span class="comment"># 对doc做一些处理</span></span><br><span class="line">    <span class="keyword">return</span> doc</span><br><span class="line"></span><br><span class="line">nlp.add_pipe(custom_component)</span><br><span class="line"></span><br><span class="line">nlp.add_pipe(component, last=<span class="literal">True</span>) <span class="comment"># 组件顺序最后 first=True 组件顺序最前</span></span><br><span class="line">nlp.add_pipe(component, before=<span class="string">&quot;ner&quot;</span>) <span class="comment"># 指定组件顺序之前 after=&quot;tagger&quot; 指定组件顺序之后</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
</search>
