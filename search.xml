<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Leetcode-剑指Offer</title>
    <url>/2020/09/05/Algorithm-jianzhioffer/</url>
    <content><![CDATA[<h4 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/">左旋转字符串</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseLeftWords</span>(<span class="params">s,n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s[n:] + s[:n]</span><br></pre></td></tr></table></figure>

<h4 id="求1-2-…-n"><a href="#求1-2-…-n" class="headerlink" title="求1+2+…+n"></a><a href="https://leetcode-cn.com/problems/qiu-12n-lcof/">求1+2+…+n</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sumNums</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    n &gt; <span class="number">1</span> <span class="keyword">and</span> sumNums(n<span class="number">-1</span>) <span class="comment"># n=1 终止递归的需求，可通过短路效应实现</span></span><br><span class="line">    res += n </span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="数组中重复的数字"><a href="#数组中重复的数字" class="headerlink" title="数组中重复的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/">数组中重复的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findRepeatNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">    fre_dict=&#123;&#125; <span class="comment"># 使用字典</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        fre_dict[i] = fre_dict.get(i,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> fre_dict[i]&gt;<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="comment"># 另一种思路 ，排序 找nums[i] == nums[i-1]</span></span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数"><a href="#数组中数字出现的次数" class="headerlink" title="数组中数字出现的次数"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/">数组中数字出现的次数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumbers</span>(<span class="params">nums</span>):</span> </span><br><span class="line">    tmp_res = <span class="number">0</span>     </span><br><span class="line">    a,b = <span class="number">0</span>,<span class="number">0</span> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        tmp_res = tmp_res ^ i  <span class="comment"># 假设需要的结果为为a和b 那么tmp_res = a^b  note: a^a = 0 </span></span><br><span class="line">    <span class="comment"># 将数组分成两部分 一部分只包含a  另一部分只包含b</span></span><br><span class="line">    pivot = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> tmp_res&amp;pivot ==<span class="number">0</span>:</span><br><span class="line">        pivot = pivot&lt;&lt;<span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> i &amp;pivot:</span><br><span class="line">            a = a^i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            b = b^i</span><br><span class="line">    <span class="keyword">return</span> [a,b]</span><br></pre></td></tr></table></figure>

<h4 id="数组中数字出现的次数-II"><a href="#数组中数字出现的次数-II" class="headerlink" title="数组中数字出现的次数 II"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/">数组中数字出现的次数 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span>(<span class="params">nums</span>):</span></span><br><span class="line">  <span class="comment"># 1.数学 (sum(set(nums))*3-sum(nums))//2  2.字典思路 3. 位运算</span></span><br><span class="line">  <span class="comment"># a^a = 0  a^0 = a 位运算</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>): <span class="comment"># 1 &lt;= nums[i] &lt; 2^31限制</span></span><br><span class="line">        idx = <span class="number">1</span> &lt;&lt; i  <span class="comment"># 0001   0010   0010</span></span><br><span class="line">        count = <span class="number">0</span> </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num &amp; idx !=<span class="number">0</span>:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> count%<span class="number">3</span> ==<span class="number">1</span>: <span class="comment"># 表明唯一的那个数在这一位上为1</span></span><br><span class="line">            res = res|idx</span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的深度"><a href="#二叉树的深度" class="headerlink" title="二叉树的深度"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">二叉树的深度</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxDepth</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> <span class="number">0</span> <span class="comment"># 递归出口</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + max(self.maxDepth(root.left),self.maxDepth(root.right))</span><br><span class="line"><span class="comment"># 非递归方法： BFS 获得层数即二叉树的深度</span></span><br></pre></td></tr></table></figure>

<h4 id="链表中倒数第k个节点"><a href="#链表中倒数第k个节点" class="headerlink" title="链表中倒数第k个节点"></a><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/">链表中倒数第k个节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getKthFromEnd</span>(<span class="params">head, k</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 遍历统计链表长度，倒是第k个节点便是顺数n-k个节点</span></span><br><span class="line">    <span class="comment"># 快慢指针思路</span></span><br><span class="line">    slow,fast = head,head</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(k): <span class="comment"># 快指针先走k步</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> fast: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">while</span> fast:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next</span><br><span class="line">    <span class="keyword">return</span> slow</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的镜像"><a href="#二叉树的镜像" class="headerlink" title="二叉树的镜像"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/">二叉树的镜像</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> <span class="comment"># 递归出口</span></span><br><span class="line">    root.left, root.right = self.mirrorTree(root.right),self.mirrorTree(root.left)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line"><span class="comment"># 非递归方法： BFS 对每一层进行迭代 </span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mirrorTree</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> queue: <span class="comment"># 对每一层的每一个节点进行遍历</span></span><br><span class="line">        node = queue.popleft()</span><br><span class="line">        tmp_left, tmp_right =node.left, node.right</span><br><span class="line">        <span class="keyword">if</span> tmp_left:</span><br><span class="line">            queue.append(tmp_left)</span><br><span class="line">            node.right = tmp_left</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.right = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">if</span> tmp_right:</span><br><span class="line">            queue.append(tmp_right)</span><br><span class="line">            node.left = tmp_right  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.left = <span class="literal">None</span>              </span><br><span class="line">    <span class="keyword">return</span> root</span><br></pre></td></tr></table></figure>

<h4 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/">打印从1到最大的n位数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printNumbers</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> [ i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">10</span>**n) ]</span><br></pre></td></tr></table></figure>

<h4 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/">替换空格</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">replaceSpace</span>(<span class="params">self, s</span>):</span></span><br><span class="line">    <span class="keyword">return</span> s.replace(<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;%20&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="从尾到头打印链表"><a href="#从尾到头打印链表" class="headerlink" title="从尾到头打印链表"></a><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">从尾到头打印链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reversePrint</span>(<span class="params">head</span>):</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> head:</span><br><span class="line">        res.append(head.val)</span><br><span class="line">        head = head.next</span><br><span class="line">    <span class="keyword">return</span> res[::<span class="number">-1</span>]    </span><br><span class="line"><span class="comment"># 递归解法 return reversePrint(head.next) + [head.val] if head else []</span></span><br></pre></td></tr></table></figure>

<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span>(<span class="params">head</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> head: <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    cur,pre = head,<span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        tmp = cur.next</span><br><span class="line">        cur.next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = tmp </span><br><span class="line">    <span class="keyword">return</span> pre </span><br></pre></td></tr></table></figure>

<h4 id="二叉搜索树的第k大节点"><a href="#二叉搜索树的第k大节点" class="headerlink" title="二叉搜索树的第k大节点"></a><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/">二叉搜索树的第k大节点</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kthLargest</span>(<span class="params">root, k</span>):</span></span><br><span class="line">    <span class="comment"># 中序遍历 获得有序数组后返回第k个大的数字。 中序遍历： 左子树 + root + 右子树</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse</span>(<span class="params">root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> </span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            res+=(traverse(root.left)) <span class="comment"># 注意不能使用append  否则会形成一个嵌套列表 </span></span><br><span class="line">        res.append(root.val)</span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            res+=(traverse(root.right))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    res = traverse(root)</span><br><span class="line">    <span class="keyword">return</span> res[-k]</span><br></pre></td></tr></table></figure>

<h4 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表####"></a><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a>####</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeTwoLists</span>(<span class="params">l1,l2</span>):</span></span><br><span class="line">    <span class="comment"># 思路1: 新建一个链表，依次插入合适的节点</span></span><br><span class="line">    cur = dummy = ListNode(<span class="number">0</span>) </span><br><span class="line">    <span class="keyword">while</span> l1 <span class="keyword">and</span> l2:</span><br><span class="line">        <span class="keyword">if</span> l1.val &lt; l2.val:</span><br><span class="line">            cur.next, l1 = l1, l1.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur.next, l2 = l2, l2.next</span><br><span class="line">        cur = cur.next</span><br><span class="line">    cur.next = l1 <span class="keyword">if</span> l1 <span class="keyword">else</span> l2</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 思路2: 使用递归进行</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l1:<span class="keyword">return</span> l2</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> l2:<span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">if</span> l1.val &lt;= l2.val:</span><br><span class="line">        l1.next = self.mergeTwoLists(l1.next,l2)</span><br><span class="line">        <span class="keyword">return</span> l1</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        l2.next = self.mergeTwoLists(l1,l2.next)</span><br><span class="line">        <span class="keyword">return</span> l2</span><br></pre></td></tr></table></figure>

<h4 id="二进制中1的个数"><a href="#二进制中1的个数" class="headerlink" title="二进制中1的个数"></a><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">二进制中1的个数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hammingWeight</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 位运算 n&amp;(n−1)  二进制数字n最右边的 1 变成 0 ，其余不变。</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += <span class="number">1</span></span><br><span class="line">        n &amp;= n - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    <span class="comment"># n&amp;1 =1 =&gt; n 二进制 最右一位 为 1 ；n&amp;1 = 0 =&gt; n 二进制 最右一位 为 0</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n:</span><br><span class="line">        res += n&amp;<span class="number">1</span></span><br><span class="line">        n = n&gt;&gt;<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">用两个栈实现队列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">       self.A,self.B = [],[]</span><br><span class="line">       <span class="comment"># A 负责入队  B负责出队</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">appendTail</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.A.append(value)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleteHead</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.B: <span class="keyword">return</span> self.B.pop()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.A: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> self.A:</span><br><span class="line">            self.B.append(self.A.pop())</span><br><span class="line">        <span class="keyword">return</span> self.B.pop()</span><br></pre></td></tr></table></figure>

<h4 id="复杂链表的复制-待定"><a href="#复杂链表的复制-待定" class="headerlink" title="复杂链表的复制 ##待定"></a><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/">复杂链表的复制</a> ##待定</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyRandomList</span>(<span class="params">head</span>):</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近公共祖先-待定"><a href="#二叉树的最近公共祖先-待定" class="headerlink" title="二叉树的最近公共祖先##待定"></a><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/">二叉树的最近公共祖先</a>##待定</h4><h4 id="和为s的连续正数序列"><a href="#和为s的连续正数序列" class="headerlink" title="和为s的连续正数序列"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">和为s的连续正数序列</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findContinuousSequence</span>(<span class="params">target</span>):</span></span><br><span class="line">    <span class="comment"># 滑动窗口解决</span></span><br><span class="line">    nums = list(range(<span class="number">1</span>,(target//<span class="number">2</span>+<span class="number">2</span>))) <span class="comment"># 候选的最大值不会超高target/2 +1</span></span><br><span class="line">    res = []</span><br><span class="line">    start_window,total = <span class="number">0</span>,nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> end_window <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">        total += nums[end_window]</span><br><span class="line">        <span class="keyword">while</span> total&gt;=target:</span><br><span class="line">            <span class="keyword">if</span> total == target:  <span class="comment"># 窗口和 = target =&gt;当前窗口加入结果 窗口起点右移</span></span><br><span class="line">                res.append(nums[start_window:end_window+<span class="number">1</span>])</span><br><span class="line">            total -= nums[start_window]</span><br><span class="line">            start_window+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="重建二叉树"><a href="#重建二叉树" class="headerlink" title="重建二叉树"></a><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/">重建二叉树</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTree</span>(<span class="params">preorder, inorder</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> preorder:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span> </span><br><span class="line">    root = preorder[<span class="number">0</span>]</span><br><span class="line">    pos = inorder.index(root)</span><br><span class="line"></span><br><span class="line">    binary_tree = TreeNode(root)</span><br><span class="line">    binary_tree.left = self.buildTree(preorder[<span class="number">1</span>:pos+<span class="number">1</span>],inorder[:pos])</span><br><span class="line">    binary_tree.right = self.buildTree(preorder[pos+<span class="number">1</span>:],inorder[pos+<span class="number">1</span>:])</span><br><span class="line">    <span class="keyword">return</span> binary_tree</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="从上到下打印二叉树-I"><a href="#从上到下打印二叉树-I" class="headerlink" title="从上到下打印二叉树 I"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树 I</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:<span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">            res.append(node.val)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>


<h4 id="从上到下打印二叉树-II"><a href="#从上到下打印二叉树-II" class="headerlink" title="从上到下打印二叉树 II"></a><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">levelOrder</span>(<span class="params">root</span>):</span></span><br><span class="line">    <span class="comment"># BFS 层序遍历 使用队列实现</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root: <span class="keyword">return</span> []</span><br><span class="line">    queue = deque()</span><br><span class="line">    queue.append(root)</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        level_size = len(queue)</span><br><span class="line">        cur_level = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(level_size):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            cur_level.append(node.val)</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        res.append(cur_level)</span><br><span class="line">    <span class="keyword">return</span> res </span><br></pre></td></tr></table></figure>

<h4 id="礼物的最大价值"><a href="#礼物的最大价值" class="headerlink" title="礼物的最大价值"></a><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/">礼物的最大价值</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxValue</span>(<span class="params">grid</span>):</span> </span><br><span class="line">    <span class="comment"># 二维dp  grid[i][j] = max(grid[i][j - 1], grid[i - 1][j]) +  grid[i][j]</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(grid)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(grid[<span class="number">0</span>])):</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">and</span> j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>: grid[i][j] += grid[i][j - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">elif</span> j == <span class="number">0</span>: grid[i][j] += grid[i - <span class="number">1</span>][j]</span><br><span class="line">            <span class="keyword">else</span>: grid[i][j] += max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j])</span><br><span class="line">    <span class="keyword">return</span> grid[<span class="number">-1</span>][<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="数组中出现次数超过一半的数字"><a href="#数组中出现次数超过一半的数字" class="headerlink" title="数组中出现次数超过一半的数字"></a><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/">数组中出现次数超过一半的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span>(<span class="params">nums</span>):</span></span><br><span class="line">    <span class="keyword">return</span> sorted(nums)[len(nums)//<span class="number">2</span>]  <span class="comment">#  排序后取中间的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#Boyer-Moore 投票法 O(n)</span></span><br><span class="line">    res = nums[<span class="number">0</span>]</span><br><span class="line">    cal = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> nums[<span class="number">1</span>:]:</span><br><span class="line">        <span class="keyword">if</span> cal ==<span class="number">0</span>: </span><br><span class="line">            res = i</span><br><span class="line">        <span class="keyword">if</span> i == res:</span><br><span class="line">            cal+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cal-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h4 id="和为s的两个数字"><a href="#和为s的两个数字" class="headerlink" title="和为s的两个数字"></a><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">和为s的两个数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">nums,target</span>):</span>  </span><br><span class="line">    left, right = <span class="number">0</span>,len(nums)<span class="number">-1</span> <span class="comment"># 使用双指针 空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">        sums = nums[left]+nums[right]</span><br><span class="line">        <span class="keyword">if</span> sums&lt;target:</span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> sums&gt;target:</span><br><span class="line">            right-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> [nums[left],nums[right]]</span><br><span class="line">    <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

<h4 id="丑数"><a href="#丑数" class="headerlink" title="丑数"></a><a href="https://leetcode-cn.com/problems/chou-shu-lcof/">丑数</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nthUglyNumber</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 带条件的动态规划</span></span><br><span class="line">    dp, a, b, c = [<span class="number">1</span>] * n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        n2, n3, n5 = dp[a] * <span class="number">2</span>, dp[b] * <span class="number">3</span>, dp[c] * <span class="number">5</span></span><br><span class="line">        dp[i] = min(n2, n3, n5)</span><br><span class="line">        <span class="keyword">if</span> dp[i] == n2: a += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n3: b += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> dp[i] == n5: c += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="调整数组顺序使奇数位于偶数前面"><a href="#调整数组顺序使奇数位于偶数前面" class="headerlink" title="调整数组顺序使奇数位于偶数前面"></a><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/">调整数组顺序使奇数位于偶数前面</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exchange</span>(<span class="params">self, nums: List[int]</span>) -&gt; List[int]:</span></span><br><span class="line">    left,right = <span class="number">0</span>,len(nums)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> left&lt;right:</span><br><span class="line">    <span class="comment"># 保证nums[left]奇数,nums[right]为偶数</span></span><br><span class="line">        <span class="keyword">if</span> nums[left]%<span class="number">2</span>==<span class="number">1</span>:  </span><br><span class="line">            left+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[right]%<span class="number">2</span> ==<span class="number">1</span>:</span><br><span class="line">                nums[left],nums[right]=nums[right],nums[left]</span><br><span class="line">                left+=<span class="number">1</span></span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                right-=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> nums</span><br></pre></td></tr></table></figure>

<h4 id="股票的最大利润"><a href="#股票的最大利润" class="headerlink" title="股票的最大利润"></a><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/">股票的最大利润</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">prices</span>):</span></span><br><span class="line">    <span class="comment"># opt[i] = max(opt[i-1],prices[i]-min(prices[:i])) 动态规划转移方程</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> prices: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    min_price = prices[<span class="number">0</span>] <span class="comment"># 存储当天前最低的股票</span></span><br><span class="line">    opt = [<span class="number">0</span>]*len(prices)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(prices)):</span><br><span class="line">        <span class="keyword">if</span> prices[i]&lt;min_price:</span><br><span class="line">            min_price = prices[i]</span><br><span class="line">        opt[i] = max(opt[i<span class="number">-1</span>],prices[i]-min_price)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> opt[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<h4 id="圆圈中最后剩下的数字"><a href="#圆圈中最后剩下的数字" class="headerlink" title="圆圈中最后剩下的数字"></a><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/">圆圈中最后剩下的数字</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Commands Often Used</title>
    <url>/2020/09/05/Commands%20Often%20Used/</url>
    <content><![CDATA[<h2 id="1-hexo"><a href="#1-hexo" class="headerlink" title="1. hexo"></a>1. hexo</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&#x27;post&#x27;</span> <span class="comment"># Create a new post</span></span><br><span class="line">$ hexo g  <span class="comment"># Generate static files  </span></span><br><span class="line">$ hexo s  <span class="comment"># Run server</span></span><br><span class="line">$ hexo d  <span class="comment"># Deploy to remote sites</span></span><br><span class="line">$ hexo clean <span class="comment"># Remove cache file (db.json) and static files (public)</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Efficiency</category>
      </categories>
      <tags>
        <tag>Commands</tag>
      </tags>
  </entry>
  <entry>
    <title>DSCI551 outline</title>
    <url>/2020/09/06/DSCI551-outline/</url>
    <content><![CDATA[<h2 id="DSCI551-Foundations-of-Data-Management"><a href="#DSCI551-Foundations-of-Data-Management" class="headerlink" title="DSCI551 - Foundations of Data Management"></a>DSCI551 - Foundations of Data Management</h2><h3 id=""><a href="#" class="headerlink" title=""></a><a href="/2020/09/06/Firebase-rest-web-api/" title="Firebase rest &amp; web api">Firebase rest &amp; web api</a></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a></h3><h3 id="-2"><a href="#-2" class="headerlink" title=""></a><a href="/2020/09/08/Storage-systems/" title="Storage systems">Storage systems</a></h3>]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Firebase rest &amp; web api</title>
    <url>/2020/09/06/Firebase-rest-web-api/</url>
    <content><![CDATA[<h2 id="Firebase-概述（BaaS）"><a href="#Firebase-概述（BaaS）" class="headerlink" title="Firebase 概述（BaaS）"></a>Firebase 概述（BaaS）</h2><p>Firebase谷歌的一款应用后台服务。借助Firebase，应用开发者们可以快速搭建应用后台。</p>
<h3 id="产品"><a href="#产品" class="headerlink" title="产品"></a>产品</h3><ol>
<li>Firebase (realtime) database: Manage <strong>JSON</strong> documents + Real-time <strong>syncing</strong> data between users and devices</li>
<li>Firebase (cloud) storage: Store images, photos, videos</li>
<li>Firebase (user) authentication: Support sign in using Google, Facebook</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li>Create a Firebase account: first use Google account,then go to Firebase console: <a href="https://console.firebase.google.com/">https://console.firebase.google.com/</a></li>
<li>Click on “Add project”  to create a Firebase project</li>
<li>Add Firebase to your web app</li>
<li>any other interesting operation …</li>
</ol>
<h3 id="关于-Realtime-database"><a href="#关于-Realtime-database" class="headerlink" title="关于 Realtime database"></a>关于 Realtime database</h3><ul>
<li>Data in JSON(Javascript Object Notation) format  <a href="/2020/09/07/JSON-review/" title="JSON-review">JSON-review</a> </li>
<li>When creating a real-time database, we should open up the access to allow us to read and write the data.</li>
<li>There are some difference between storing style from JSON file and Firebase real-time database<ol>
<li>JSON文件中的array元素在Realtime database下以object的形式存在，object对应的key为数组元素的索引</li>
<li>JSON文件可以保存value为null的键值对，Realtime database则会忽略这一对键值对<br><img src="/image/firebase1.png"></li>
</ol>
</li>
</ul>
<h2 id="Firebase-REST-API"><a href="#Firebase-REST-API" class="headerlink" title="Firebase REST API"></a>Firebase REST API</h2><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p> REST：Representation State Transfer，表现层状态转移<br> 一句话解释的话就是:通过URL定位资源，用HTTP动词（GET, POST, PUT, DELETE)描述操作从而用来实现前后端数据传输的协议。</p>
<h3 id="命令行进行http数据传输：curl"><a href="#命令行进行http数据传输：curl" class="headerlink" title="命令行进行http数据传输：curl"></a>命令行进行http数据传输：curl</h3><p>  For command operation, it’s convenient to use <strong>curl</strong> (Command line tool for data transfer)<br>  curl详细使用：<a href="https://itbilu.com/linux/man/4yZ9qH_7X.html">https://itbilu.com/linux/man/4yZ9qH_7X.html</a><br>  注意，curl大小写敏感，请求的命令参数均为大写字符</p>
<h3 id="curl例子-CRUD"><a href="#curl例子-CRUD" class="headerlink" title="curl例子 - CRUD"></a>curl例子 - CRUD</h3><p>  PUT &amp; POST (C), GET (R), PATCH (U) ,DELETE (D)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">JSON tree:</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;firstName&quot;</span>: <span class="string">&quot;John&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lastName&quot;</span>: <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">  <span class="string">&quot;isMarried&quot;</span>: false,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: <span class="number">25</span>,</span><br><span class="line">  <span class="string">&quot;height_cm&quot;</span>: <span class="number">167.6</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;streetAddress&quot;</span>: <span class="string">&quot;22nd Street&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;NY&quot;</span>,</span><br><span class="line">    <span class="string">&quot;postalCode&quot;</span>: <span class="string">&quot;10021-3100&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;phoneNumbers&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;home&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;212 555-1234&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;office&quot;</span>,</span><br><span class="line">      <span class="string">&quot;number&quot;</span>: <span class="string">&quot;646 555-4567&quot;</span>,</span><br><span class="line">      <span class="string">&quot;xyz&quot;</span>: null</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;children&quot;</span>: [],</span><br><span class="line">  <span class="string">&quot;spouse&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;scores&quot;</span>: [<span class="number">8.5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="GET-get-the-specific-resource"><a href="#GET-get-the-specific-resource" class="headerlink" title="GET: get the specific resource"></a>GET: get the specific resource</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;address&#x2F;city.json&#39;   return: &quot;New York&quot;%  </span><br><span class="line">-X   可以省略 直接 curl GET url; GET  可以省略 直接 curl url</span><br><span class="line"></span><br><span class="line">$ curl &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;phoneNumbers&#x2F;0.json&#39; #refer to arr element by index</span><br><span class="line">return:&#123;&quot;number&quot;:&quot;212 555-1234&quot;,&quot;type&quot;:&quot;home&quot;&#125;%  </span><br></pre></td></tr></table></figure>

<h4 id="PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”"><a href="#PUT-write-a-given-value-e-g-“Mary”-to-a-specify-node-e-g-“spouse”" class="headerlink" title="PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)"></a>PUT: write a given value (e.g., “Mary”) to a specify node (e.g., “spouse”)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Add if node not exists (could add embedded nodes) - 添加数据</span><br><span class="line">Overwrite if node already has value               - 重写数据</span><br><span class="line"></span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Mary&quot;&#39;  # 注意引号</span><br><span class="line"></span><br><span class="line">#This will add a new node &quot;country&quot; (assuming it does not exist yet) </span><br><span class="line">#and a child of this node with key &quot;province&quot; and content: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;</span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country&#x2F;province.json&#39; -d &#39;&#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#39; </span><br><span class="line">$ curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="POST-add-new-value-to-a-given-node"><a href="#POST-add-new-value-to-a-given-node" class="headerlink" title="POST: add new value to a given node"></a>POST: add new value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Automatically generates a new key &amp; then stores the value for the new key</span><br><span class="line">由于对于添加的数据，其自动生成一个key，所以保证不会重写数据(In contrast, PUT will simply overwrite the key)</span><br><span class="line"> </span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Anhui&quot;&#125;&#125;&#39;</span><br><span class="line">$ curl -X POST &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d  &#39;&quot;Anhui&quot;&#39;</span><br></pre></td></tr></table></figure>

<h4 id="PATCH-upsert-a-value-to-a-given-node"><a href="#PATCH-upsert-a-value-to-a-given-node" class="headerlink" title="PATCH:  upsert a value to a given node"></a>PATCH:  upsert a value to a given node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Performs the update if value already exists  -更新节点</span><br><span class="line">Otherwise, it inserts the new value          -插入新节点</span><br><span class="line">PATCH本质上是一个深度搜索符合节点的条件进行更新或者添加)</span><br><span class="line"></span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;country.json&#39; -d &#39;&#123;&quot;province&quot;: &#123;&quot;name&quot;: &quot;Hubei&quot;&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">好处:相比于PUT（对于已经存在的节点进行全局的修改），本质上来说PATCH实现的是对该节点的局部更新</span><br><span class="line">注意:当需要更新的节点没有子节点（仅仅是一个key-value格式），无法使用PATCH，因为 -d 参数后需要传入键值对的格式</span><br><span class="line">curl -X PATCH &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # fail</span><br><span class="line">&#123;</span><br><span class="line">  &quot;error&quot; : &quot;Invalid data; couldn&#39;t parse JSON object. Are you sending a JSON object with valid key names?&quot;</span><br><span class="line">&#125;</span><br><span class="line">curl -X PUT &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39; -d &#39;&quot;Sam&quot;&#39; # success</span><br></pre></td></tr></table></figure>
<h4 id="DELETE-delete-a-node"><a href="#DELETE-delete-a-node" class="headerlink" title="DELETE:  delete a node"></a>DELETE:  delete a node</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X DELETE &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;spouse.json&#39;</span><br></pre></td></tr></table></figure>

<h4 id="从数据增加、减少上对PUT、PATCH和POST进行比较"><a href="#从数据增加、减少上对PUT、PATCH和POST进行比较" class="headerlink" title="从数据增加、减少上对PUT、PATCH和POST进行比较"></a>从数据增加、减少上对PUT、PATCH和POST进行比较</h4><p>PUT可能造成数据的增加（添加新节点下的value）和减少（overwrite整个节点导致其内嵌的节点被删除）；<br>PATCH可能造成数据的增加（添加新节点下的value)和减少（update节点的用更少的数据去取代原先的数据）<br>POST一定会造成数据的增加（因为会自动加上key）；</p>
<h4 id="data-querying-by-RESful-API"><a href="#data-querying-by-RESful-API" class="headerlink" title="data querying by RESful API"></a>data querying by RESful API</h4><ul>
<li>orderBy=”$key”  </li>
<li>orderBy=”<path-to-child-key>“</li>
<li>orderBy=”$value”  需要在Realtime database的Rules先声明</li>
<li>startAt/endAt</li>
<li>equalTo</li>
<li>limitToFirst/limitToLast </li>
</ul>
<p>Specified in database rules:<br><a href="https://firebase.google.com/docs/database/security/indexing-data">https://firebase.google.com/docs/database/security/indexing-data</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;equalTo&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$key&quot;&amp;startAt&#x3D;&quot;1&quot;&#39;</span><br><span class="line">curl -X GET &#39;https:&#x2F;&#x2F;rest-apidemo.firebaseio.com&#x2F;scores.json?orderBy&#x3D;&quot;$value&quot;&#39;</span><br><span class="line"></span><br><span class="line">Orders ascendingly:</span><br><span class="line">null -&gt; false -&gt;true -&gt; number -&gt; string -&gt; object</span><br></pre></td></tr></table></figure>


<h2 id="REST-API-in-Python"><a href="#REST-API-in-Python" class="headerlink" title="REST API in Python"></a>REST API in Python</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;xxxx&#39;</span><br><span class="line">data &#x3D; &#39;xxx&#39;</span><br><span class="line"></span><br><span class="line">requests.get(url) </span><br><span class="line">requests.put(url, data)</span><br><span class="line">requests.patch(url, data)</span><br><span class="line">requests.delete(url)</span><br><span class="line">requests.post(url, data)</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Commands</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>JSON-review</title>
    <url>/2020/09/07/JSON-review/</url>
    <content><![CDATA[<h2 id="JSON概述"><a href="#JSON概述" class="headerlink" title="JSON概述"></a>JSON概述</h2><p><strong>JSON</strong>（<strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation)，由道格拉斯·克罗克福特构想和设计、轻量级的数据交换语言,该语言以易于让人阅读的文字为基础，用来<strong>传输由属性值或者序列性的值组成的数据对象</strong>。尽管JSON是JavaScript的一个子集，但JSON是独立于语言的文本格式。</p>
<ul>
<li>Light-weight data exchange format<br>Much simpler than XML; Language-independent; Inspired by the syntax of JavaScript object literals</li>
<li>Some differences from JavaScript objects<br><strong>String in JSON must be double-quoted</strong>; Okay to single-quote in JavaScript (&amp; Python)</li>
<li>JSON is case-sensitive</li>
</ul>
<p>一句话表达就是，JSON是一种格式，基于文本，优于轻量，用于交换数据，由于其用文本格式的保存方式，所以一般也叫JSON字符串。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li>value = string | number | object | array | true | false | null</li>
<li>object = {} | { members }<ul>
<li>members = pair | pair, members </li>
<li>pair = string : value</li>
</ul>
</li>
<li>array = [] | [ elements ]<ul>
<li>elements = value | value, elements</li>
</ul>
</li>
</ul>
<p>一般情况下，JSON大多为一个array，array里的每一个元素为一个object，object可以理解为字典<br>JSON 在线检查器:   <a href="https://www.json.cn/">https://www.json.cn/</a></p>
<h2 id="Python中使用JSON"><a href="#Python中使用JSON" class="headerlink" title="Python中使用JSON"></a>Python中使用JSON</h2><h3 id="encode-decode"><a href="#encode-decode" class="headerlink" title="encode/decode"></a>encode/decode</h3><p>JSON操作主要分为两个：</p>
<ol>
<li>encode，将Python对象转化为JSON文本，主要函数 dump( ) dumps( )</li>
<li>decode，将JSON文本转化为Python对象，主要函数 load( ) loads( )</li>
</ol>
<h3 id="转化规则"><a href="#转化规则" class="headerlink" title="转化规则"></a>转化规则</h3><table>
<thead>
<tr>
<th align="center">Python</th>
<th align="center">JSON</th>
</tr>
</thead>
<tbody><tr>
<td align="center">list/tuple</td>
<td align="center">array</td>
</tr>
<tr>
<td align="center">dict</td>
<td align="center">object</td>
</tr>
<tr>
<td align="center">None</td>
<td align="center">null</td>
</tr>
<tr>
<td align="center">True</td>
<td align="center">true</td>
</tr>
<tr>
<td align="center">False</td>
<td align="center">false</td>
</tr>
<tr>
<td align="center">‘abc’</td>
<td align="center">“abc”</td>
</tr>
</tbody></table>
<p>关于Python字典转JSON文本的说明：</p>
<ul>
<li>Keys in Python can be number, string, or tuple. </li>
<li>Number is also converted to string.</li>
<li>But tuple (with two or more components) is not acceptable by dumps()/dump()</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json <span class="comment"># json库为Python自带的标准库</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON encoder Python object =&gt; JSON document   </span></span><br><span class="line">json.dumps([<span class="number">3</span>, <span class="string">&#x27;abc&#x27;</span>, <span class="literal">True</span>, <span class="literal">None</span>])  <span class="comment"># &#x27;[3, &quot;abc&quot;, true, null]&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python object =&gt; JSON file</span></span><br><span class="line">data = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;Sam&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">23</span>&#125;</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> out_file:</span><br><span class="line">    json.dump(data,out_file)</span><br><span class="line"></span><br><span class="line"><span class="comment">## JSON decoder </span></span><br><span class="line">json.loads(<span class="string">&#x27;[&quot;foo&quot;, &#123;&quot;bar&quot;:[&quot;baz&quot;, null, 1.0, 2]&#125;]&#x27;</span>) <span class="comment"># [&#x27;foo&#x27;, &#123;&#x27;bar&#x27;: [&#x27;baz&#x27;, None, 1.0, 2]&#125;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># JSON file =&gt; Python object</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">&#x27;user_info.json&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> in_file:</span><br><span class="line">    data = json.load(in_file)</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Python</tag>
        <tag>File Format</tag>
      </tags>
  </entry>
  <entry>
    <title>Storage systems</title>
    <url>/2020/09/08/Storage-systems/</url>
    <content><![CDATA[<h2 id="Storage-Device"><a href="#Storage-Device" class="headerlink" title="Storage Device"></a>Storage Device</h2><h3 id="Hierarchy"><a href="#Hierarchy" class="headerlink" title="Hierarchy"></a>Hierarchy</h3><p><img src="/image/storage_hierarchy.png"></p>
<h3 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h3><ul>
<li>Capacity(bytes) - How much data it can hold</li>
<li>Cost($) -  Price per byte of storage</li>
<li>Bandwidth(bytes/sec) - Number of bytes that can be transferred per second;  read and write bandwidth may be different</li>
<li>Latency(sec) - Time elapsed, waiting for response/delivery of data</li>
</ul>
<h3 id="Basic-Function-CRUD"><a href="#Basic-Function-CRUD" class="headerlink" title="Basic Function : CRUD"></a>Basic Function : CRUD</h3><ul>
<li>C(reate)/write</li>
<li>R(ead)</li>
<li>U(pdate)/overwrite</li>
<li>D(elete)</li>
</ul>
<h3 id="Some-terms"><a href="#Some-terms" class="headerlink" title="Some terms"></a>Some terms</h3><ul>
<li>Access times: Time taken before drive is ready to transfer data 一般来说，物理设备（硬盘，内存..）在进行数据的转换前需要索引到目标位置， 内存-纳秒 SSD-微秒 HDD-毫秒</li>
<li>Access pattern: how storage read/write data <ul>
<li>Sequential: Data to be accessed are located next to each other or sequentially on the device</li>
<li>Random: Access data located randomly on storage device</li>
</ul>
</li>
<li>Completion Time：Time to complete an read/write operation <ul>
<li><strong>CompletionTime = Latency + Size/Bandwidth</strong></li>
<li>Depends on lots of factors(device, operation type, access pattern…)</li>
</ul>
</li>
</ul>
<p>Note: 这里主要讨论HDD和SSD</p>
<h2 id="Hard-Disk-Drive"><a href="#Hard-Disk-Drive" class="headerlink" title="Hard Disk Drive"></a>Hard Disk Drive</h2><h3 id="Organization"><a href="#Organization" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/hdd.png"></p>
<ul>
<li>One or more spinning magnetic platters, typically two surface per platter</li>
<li>Data stored in tracks</li>
<li>Disk arm positions over the radial positon - swings across tracks but don’t extend</li>
<li>Data is read/written by disk head as platter spins</li>
</ul>
<p>Hard disk head movement while copying files between two folders：<br><a href="https://www.youtube.com/watch?v=BlB49F6ExkQ">https://www.youtube.com/watch?v=BlB49F6ExkQ</a></p>
<h3 id="Physical-characteristics"><a href="#Physical-characteristics" class="headerlink" title="Physical characteristics"></a>Physical characteristics</h3><ul>
<li>3.5” (diameter, common in desktops), 2.5” (common in laptops)</li>
<li>Rotational Speed: 4800/5400/7200/10000 RPM (rotations per minute)</li>
<li>Between 5-7 platters</li>
<li>Current capacity up to 10TB</li>
</ul>
<h3 id="Data-Storage"><a href="#Data-Storage" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>1 platter  is divided into a number of tracks</li>
<li>1 tracker is divided into N fixed size sectors<ul>
<li>sector size: 4KB</li>
<li>Entire sector is written “atomically” -&gt; sector为最小的操作单元，所以不论读写都首先进行sector的寻址</li>
</ul>
</li>
</ul>
<h3 id="Address-Method-CHS-cylinder-head-sector"><a href="#Address-Method-CHS-cylinder-head-sector" class="headerlink" title="Address Method - CHS(cylinder-head-sector)"></a>Address Method - CHS(cylinder-head-sector)</h3><h4 id="overview"><a href="#overview" class="headerlink" title="overview"></a>overview</h4><p>CHS is an early way to address a sector. (LBA(Logical Block Addressing) is  more common now.) </p>
<p><img src="/image/CHS.png"></p>
<p>举个例子：<br>#cylinders: 256<br>#heads: 16 (i.e., 8 platters, 2 heads/platter)<br>#sectors/track: 64<br>sector size = 4KB<br>=&gt; capacity of the drive:  2^8 * 2^6 * 2^2* 2^10 * 2^4 = 2^30 = 1GB</p>
<h4 id="address-step"><a href="#address-step" class="headerlink" title="address step"></a>address step</h4><p><strong>According to CHS, data can be located before transferring, then data can be transferred</strong></p>
<ol>
<li>Wait for the disk haed on right track    - seek time <ol>
<li>On average seek time is about  1⁄3  max seek time</li>
<li><img src="/image/seek-time.png"></li>
</ol>
</li>
<li>wait for the right sector to rotate under the head. - rotational latency <ol>
<li>On average: about 1⁄2 of time of a full rotation</li>
<li>example:  Assume 10,000 RPM (rotations per minute) 60000 ms/ 10000 rotations  = 6ms / rotation</li>
</ol>
</li>
</ol>
<h3 id="Data-Operation"><a href="#Data-Operation" class="headerlink" title="Data Operation"></a>Data Operation</h3><blockquote>
<p>T = T_seek + T_rotation + T_transfer<br>T_seek : Time to get the disk head on right track<br>T_rotation :Time to wait for the right sector to rotate under the head<br>T_transfer: Time to actually transfer data</p>
</blockquote>
<h4 id="T-transfer"><a href="#T-transfer" class="headerlink" title="T_transfer"></a>T_transfer</h4><p>Assume that data will be transferred:  512KB, 128 MB/sec transmission bandwidth<br>Transfer time:  512KB/128MB * 1000ms = 4ms</p>
<h4 id="Actual-Bandwidth"><a href="#Actual-Bandwidth" class="headerlink" title="Actual Bandwidth"></a>Actual Bandwidth</h4><p>Actual Bandwidth = data / actual time ，所以一般情况下实际带宽会小</p>
<h4 id="数据传输中的block和sector区分"><a href="#数据传输中的block和sector区分" class="headerlink" title="数据传输中的block和sector区分"></a>数据传输中的block和sector区分</h4><ul>
<li>Sector is the  basic unit of hard disk dirve</li>
<li>Block is the basic unit of file system</li>
<li>Block has 1 or more sectors  （in this course, assuming one block = one sector）</li>
</ul>
<p>硬盘本身没有block的概念，block概念存在于文件系统的概念中，文件系统是一个块一个块的读取数据，如果是按照一个sector一个sector的来读数据，太慢了，所以才有了block这样一个逻辑块的概念。</p>
<h4 id="不同access-pattern对读写的影响"><a href="#不同access-pattern对读写的影响" class="headerlink" title="不同access pattern对读写的影响"></a>不同access pattern对读写的影响</h4><ul>
<li>Sequential operation:<ul>
<li>May assume all sectors involved are on the same track<br>– need to seek to the right track or rotate to the first sector （一次seektime）<br>– But no rotation/seeking needed afterwardSSD</li>
</ul>
</li>
<li>Random operation:  <ul>
<li>May assume all sectors are on different tracks and sectors （多次seektime）</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example: 7ms avg seek,  10,000 RPM  50 MB/sec transfer rate 4KB/block</span><br><span class="line">Sequential access of 10 MB:</span><br><span class="line">– Completion time = 7ms + 60*1000/10000/2 ms + 10/50 *1000 ms = 210ms</span><br><span class="line">– Actual bandwidth = 10MB/210ms = 47.62 MB/s</span><br><span class="line"></span><br><span class="line">Random access of 10 MB </span><br><span class="line">– block numbers: 10*1000/4 = 2500  (assume 1 block = 1 sector)</span><br><span class="line">– Completion time = 2500 * (7 + 3 + 4/50) = 25.2s</span><br><span class="line">– Actual bandwidth = 10MB / 25.2s = 0.397 MB/s</span><br></pre></td></tr></table></figure>

<h2 id="Soild-State-Drive"><a href="#Soild-State-Drive" class="headerlink" title="Soild State Drive"></a>Soild State Drive</h2><h3 id="Organization-1"><a href="#Organization-1" class="headerlink" title="Organization"></a>Organization</h3><p><img src="/image/ssd.png"></p>
<p>SSD contains a number of flash memory chips</p>
<p><img src="/image/chip.png"></p>
<p>chip -&gt; dies -&gt; planes -&gt; blocks -&gt; pages (rows) -&gt; cells</p>
<h3 id="Characteristics"><a href="#Characteristics" class="headerlink" title="Characteristics"></a>Characteristics</h3><ul>
<li>All electronic, made from flash memory</li>
<li>Limited lifetime, can only write a limited number of times.</li>
<li>More expensive, less capacity  - 3 times or more expensive</li>
<li>Significantly better latency: no seek or rotational delay</li>
<li>Much better performance on random (however, write has much higher latency than read )</li>
</ul>
<h3 id="Data-Storage-1"><a href="#Data-Storage-1" class="headerlink" title="Data Storage"></a>Data Storage</h3><ul>
<li>Cells are made of floating-gate transistors : By applying high positive/negative voltage to control gate, electrons can be attracted to or repelled from floating gate<ul>
<li>State = 1, if no electrons in the floating gate</li>
<li>State = 0, if there are electrons (negative charges)<br>– Electrons stuck there even when power is off<br>– So state is retained</li>
</ul>
</li>
<li>Data in SSD are represented by the ‘01010…’ formats, that is the state of the electrons</li>
</ul>
<p><img src="/image/floating-gate.png"></p>
<h3 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h3><h4 id="Read"><a href="#Read" class="headerlink" title="Read"></a>Read</h4><ul>
<li>Electrons on the floating gate affect the threshold voltage for the floating gate transistor to conduct</li>
<li>Higher voltage needed when gate has electrons</li>
</ul>
<p><img src="/image/ssd_read.png"></p>
<p>Steps: </p>
<ol>
<li>Apply Vint (intermediate voltage) </li>
<li>If the current is detected, gate has no electrons=&gt; bit = 1</li>
<li>If no current, gate must have electrons =&gt; bit = 0</li>
</ol>
<p><u><strong>Page is the smallest unit that can be read</strong></u></p>
<h4 id="Write-and-Erase"><a href="#Write-and-Erase" class="headerlink" title="Write and Erase"></a>Write and Erase</h4><h4 id="Write-and-erase"><a href="#Write-and-erase" class="headerlink" title="Write and erase"></a>Write and erase</h4><ul>
<li>Write: 1 =&gt; 0 (get electron)<ul>
<li>Apply high positive voltage (&gt;&gt; voltage for read) to the control gate</li>
<li>Attract electrons from channel to floating gate (through quantum tunneling)</li>
<li>Page is the smallest unit for write</li>
</ul>
</li>
<li>Erase: 0 =&gt; 1 (make electrons empty)<ul>
<li>Need to apply much higher negative voltage to the control gate</li>
<li>Get rid of electrons from floating gate</li>
<li>May stress surrounding cells(dangerous to do on individual pages)</li>
<li>Block is the smallest unit for erase</li>
</ul>
</li>
</ul>
<h3 id="P-E-cycle"><a href="#P-E-cycle" class="headerlink" title="P/E cycle"></a>P/E cycle</h3><blockquote>
<p>P/E cycle: Data is written to cells (P) and then erased (E)<br>Every write &amp; erase damages oxide layer surrounding the floating-gate to some extent</p>
</blockquote>
<ul>
<li>Page is the smallest unit for read and write (write is also called program, 1-&gt;0)</li>
<li>Block is the smallest unit for erase (0-&gt;1) – i.e., make cells “empty” (i.e., no electrons)  (关于为什么使用block作为最小擦除单元：SSD的物理结构导致，擦除过程会作用到整个block施加高电压，将电子吸引出来)</li>
</ul>
]]></content>
      <tags>
        <tag>Operating System</tag>
      </tags>
  </entry>
  <entry>
    <title>CSCI570-outline</title>
    <url>/2020/09/08/CSCI570-outline/</url>
    <content><![CDATA[<p>hello world!</p>
]]></content>
      <tags>
        <tag>Course</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode-滑动窗口</title>
    <url>/2020/09/09/Algorithm-sliding-window/</url>
    <content><![CDATA[<h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p><u>连续</u>子数组</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>根据要求，找到第一个满足条件的窗口</li>
<li>调整窗口(右移/左移)使其继续满足要求，并进行重复</li>
<li>得到最合适的窗口即为答案</li>
</ul>
<h3 id="Leetcode例题"><a href="#Leetcode例题" class="headerlink" title="Leetcode例题"></a>Leetcode例题</h3><h5 id="无重复字符的最长子串"><a href="#无重复字符的最长子串" class="headerlink" title="无重复字符的最长子串"></a><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/">无重复字符的最长子串</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> len(s) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_start,res = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(s)):</span><br><span class="line">        char = s[window_end]</span><br><span class="line">        <span class="keyword">if</span> char <span class="keyword">in</span> dic <span class="keyword">and</span> dic[char]&gt;=window_start: <span class="comment"># 注意这里的第二个条件dic[char]&gt;=window_start！！ 起到一个覆盖的作用</span></span><br><span class="line">            window_start = dic[char] +<span class="number">1</span></span><br><span class="line">        dic[char] = window_end</span><br><span class="line">        width = window_end-window_start+<span class="number">1</span></span><br><span class="line">        res = max(width,res)</span><br><span class="line">    <span class="keyword">return</span> res  </span><br></pre></td></tr></table></figure>

<h5 id="大小为-K-且平均值大于等于阈值的子数组数目"><a href="#大小为-K-且平均值大于等于阈值的子数组数目" class="headerlink" title="大小为 K 且平均值大于等于阈值的子数组数目"></a><a href="https://leetcode-cn.com/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/">大小为 K 且平均值大于等于阈值的子数组数目</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numOfSubarrays</span>(<span class="params">arr,k,threshold</span>):</span></span><br><span class="line">    <span class="keyword">if</span> arr == [] <span class="keyword">or</span> len(arr)&lt;k:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    window_sum,window_start,res = <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    temp = threshold*k</span><br><span class="line">    <span class="keyword">for</span> window_end <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        window_sum+=arr[window_end]</span><br><span class="line">        <span class="keyword">if</span> window_end&gt;=k<span class="number">-1</span>:</span><br><span class="line">            <span class="keyword">if</span> window_sum &gt;=temp:</span><br><span class="line">                res+=<span class="number">1</span></span><br><span class="line">            window_sum-=arr[window_start]</span><br><span class="line">            window_start+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>

<h5 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement/">替换后的最长重复字符</a></h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a><a href="https://leetcode-cn.com/problems/minimum-window-substring/">最小覆盖子串</a></h5><h5 id="滑动窗口中位数"><a href="#滑动窗口中位数" class="headerlink" title="滑动窗口中位数"></a><a href="https://leetcode-cn.com/problems/sliding-window-median/">滑动窗口中位数</a></h5><h5 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">滑动窗口最大值</a></h5>]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Python</tag>
      </tags>
  </entry>
</search>
